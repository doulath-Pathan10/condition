// DucumentUploadMainSCR.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import DucumentUploadMainSCR from './document-upload-main-scr';
import * as reactRedux from 'react-redux';
import * as services from '../../../../preApproval/services/preApprovalPostServices';
import * as commonServices from '../../../../../services/common-service';
import * as constants from '../../../../../utils/common/constants';
import * as utils from '../../../../../utils/common/change.utils';

jest.mock('../../../../preApproval/services/preApprovalPostServices');
jest.mock('../../../../../services/common-service');
jest.mock('../../../../../utils/common/change.utils');
jest.mock('../documentType/document-type-dynamic', () => () => <div>DocumentTypeDynamicMock</div>);
jest.mock('../../../../../shared/components/close/close', () => () => <div>CloseMock</div>);
jest.mock('../../../../../shared/components/spinner/spinner', () => () => <div>SpinnerMock</div>);

const useDispatchMock = jest.fn();
const useSelectorMock = jest.spyOn(reactRedux, 'useSelector');

describe('DucumentUploadMainSCR', () => {
  const dispatchMock = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    useDispatchMock.mockReturnValue(dispatchMock);
    jest.spyOn(reactRedux, 'useDispatch').mockReturnValue(dispatchMock);

    useSelectorMock.mockImplementation(callback =>
      callback({
        stages: {
          dynamicDocumentsUpload: {
            documentData: {},
            HKIDQRCodeData: {},
            changeIconColorIdentityProof: false,
            documentCount: 1,
            success: true,
            fileSectionData: null,
          },
          stages: [
            {
              stageId: 'ld-1',
              stageInfo: {
                applicant_documents: [
                  {
                    document_list: [
                      {
                        document_options: [
                          {
                            document_types: [
                              { uploaded_documents: ['file1'] },
                              { uploaded_documents: null },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
                application: {
                  channel_reference: '123',
                  response_type: 'SOFT',
                  response_action: 'CONTINUE',
                },
                products: [{ product_category: 'CC' }],
              },
            },
          ],
        },
        preApproval: {
          resumeAllowed: 'Y',
        },
      })
    );

    utils.getUrl.getParameterByName = jest.fn().mockReturnValue(null);
    utils.getUrl.getLanguageInfo = jest.fn().mockReturnValue(constants.CONSTANTS.LANG_EN);
  });

  it('renders initial UI with document count', () => {
    render(<DucumentUploadMainSCR />);
    expect(screen.getByText('DocumentTypeDynamicMock')).toBeInTheDocument();
    expect(screen.getByText('CloseMock')).toBeInTheDocument();
    expect(screen.getByText('1/1')).toBeInTheDocument();
  });

  it('shows spinner when stageId is ld-1 and showSpinner is true', () => {
    useSelectorMock.mockImplementationOnce(callback =>
      callback({
        stages: {
          dynamicDocumentsUpload: {
            fileSectionData: null,
            success: true,
            documentCount: 1,
          },
          stages: [{ stageId: 'ld-1', stageInfo: { applicant_documents: [], application: {}, products: [] } }],
        },
        preApproval: { resumeAllowed: 'Y' },
      })
    );

    render(<DucumentUploadMainSCR />);
    expect(screen.queryByText('SpinnerMock')).not.toBeNull();
  });

  it('disables Continue button if documentCount does not match total', () => {
    useSelectorMock.mockImplementation(callback =>
      callback({
        stages: {
          dynamicDocumentsUpload: {
            fileSectionData: null,
            success: true,
            documentCount: 0,
          },
          stages: [
            {
              stageId: 'ld-1',
              stageInfo: {
                applicant_documents: [
                  {
                    document_list: [
                      {
                        document_options: [
                          {
                            document_types: [
                              { uploaded_documents: null },
                              { uploaded_documents: null },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
                application: {
                  channel_reference: '123',
                },
                products: [{ product_category: 'PL' }],
              },
            },
          ],
        },
        preApproval: { resumeAllowed: 'Y' },
      })
    );

    render(<DucumentUploadMainSCR />);
    const continueBtn = screen.getByRole('button');
    expect(continueBtn).toBeDisabled();
  });

  it('calls post services on Continue click for success flow', async () => {
    (services.postTMXUserSession as jest.Mock).mockResolvedValue({
      status: 200,
      data: { review_status: 'pass' },
    });
    (services.postFinalAcknowledge as jest.Mock).mockResolvedValue({
      status: 202,
    });
    (services.postDocSaveData as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        application: {
          response_type: 'SOFT',
          response_action: 'CONTINUE',
        },
        applicants: {},
        applicant_documents: [],
      },
    });

    render(<DucumentUploadMainSCR />);
    const continueBtn = screen.getByRole('button');
    fireEvent.click(continueBtn);

    await waitFor(() => {
      expect(services.postTMXUserSession).toHaveBeenCalled();
      expect(services.postFinalAcknowledge).toHaveBeenCalled();
      expect(services.postDocSaveData).toHaveBeenCalled();
    });
  });

  it('handles failure in postTMXUserSession', async () => {
    (services.postTMXUserSession as jest.Mock).mockResolvedValue({
      status: 500,
    });

    render(<DucumentUploadMainSCR />);
    const continueBtn = screen.getByRole('button');
    fireEvent.click(continueBtn);

    await waitFor(() => {
      expect(dispatchMock).toHaveBeenCalledWith(expect.objectContaining({
        type: expect.stringContaining('error'),
      }));
    });
  });

  it('shows footer and copyright', () => {
    render(<DucumentUploadMainSCR />);
    expect(screen.getByText(constants.CONSTANTS.footerContent1)).toBeInTheDocument();
    expect(screen.getByText(constants.CONSTANTS.footerContent2)).toBeInTheDocument();
    expect(screen.getByText(constants.CONSTANTS.footerContent3)).toBeInTheDocument();
    expect(screen.getByText(constants.CONSTANTS.scbHkCopyRights_EN)).toBeInTheDocument();
  });
});

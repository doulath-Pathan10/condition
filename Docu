import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import OnboardingBeforeStart from './OnboardingBeforeStart';
import { getData, getPDFData } from '../../services/preApprovalServices';
import { useDispatch, useSelector } from 'react-redux';
import { getUrl } from '../../../../utils/common/change.utils';
import { CONSTANTS } from '../../../../utils/common/constants';

// Mock the external dependencies
jest.mock('react-redux', () => ({
  useDispatch: jest.fn(),
  useSelector: jest.fn(),
}));

jest.mock('../../services/preApprovalServices', () => ({
  getData: jest.fn(),
  getPDFData: jest.fn(),
}));

jest.mock('../../../../utils/common/change.utils', () => ({
  getUrl: {
    getLanguageInfo: jest.fn(),
  },
}));

jest.mock('../../../../shared/components/pdf/pdf', () => () => <div>Mock PDF Component</div>);
jest.mock('../../../../shared/components/spinner/spinner', () => () => <div>Mock Spinner</div>);

describe('OnboardingBeforeStart Component', () => {
  const mockDispatch = jest.fn();
  const mockOnScrollEnd = jest.fn();
  const mockNextPage = jest.fn();

  const mockStore = {
    stages: {
      stages: [{
        stageInfo: {
          products: [{
            campaign: 'HKPIL23PLSTP10',
          }],
        },
      }],
    },
    preApproval: {
      formConfigmetaData: {
        products: [{
          campaign: 'HKPIL23PLSTP10',
        }],
      },
    },
  };

  const mockPdfResponse = {
    data: {
      products: {
        HKPIL23PLSTP10: [{ pdfURL: 'https://pt.sc.com/test.pdf' }],
      },
      productsMob: {
        HKPIL23PLSTP10: [{ pdfURL: 'https://pt.sc.com/mobile/test.pdf' }],
      },
      CampaignTnC: {
        HKPIL23PLSTP10: [{ pdfURL: 'https://pt.sc.com/tnc.pdf' }],
      },
      CampaignTnCMob: {
        HKPIL23PLSTP10: [{ pdfURL: 'https://pt.sc.com/mobile/tnc.pdf' }],
      },
      tncLinkCampaignCode: {
        HKPIL23PLSTP10: [{
          pdfLinks: [
            { Title: 'II. Personal Loan Terms', url: 'test1.pdf' },
            { Title: 'III. Client Terms', url: 'test2.pdf' },
            { Title: 'Welcome Offers', url: 'test3.pdf' },
          ],
        }],
      },
    },
  };

  beforeEach(() => {
    (useDispatch as jest.Mock).mockReturnValue(mockDispatch);
    (useSelector as jest.Mock).mockImplementation((selector) => selector(mockStore));
    (getData as jest.Mock).mockResolvedValue(mockPdfResponse);
    (getPDFData as jest.Mock).mockResolvedValue('mock-pdf-data');
    (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('en');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('renders spinner initially', () => {
    render(
      <OnboardingBeforeStart
        isVisible={true}
        onScrollEnd={mockOnScrollEnd}
        stageID={0}
        nextPage={mockNextPage}
      />
    );
    expect(screen.getByText('Mock Spinner')).toBeInTheDocument();
  });

  describe('Stage 0 (KFS Document)', () => {
    it('loads and displays KFS document for desktop', async () => {
      Object.defineProperty(window.navigator, 'userAgent', {
        value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(getData).toHaveBeenCalled();
        expect(getPDFData).toHaveBeenCalledWith('https://pt.sc.com/test.pdf');
        expect(mockDispatch).toHaveBeenCalledTimes(4); // setLoader(true), setKfsDocumentPdf, setLoader(false)
        expect(screen.getByText('Mock PDF Component')).toBeInTheDocument();
        expect(screen.getByText(CONSTANTS.DownloadBtn)).toBeInTheDocument();
      });
    });

    it('loads and displays KFS document for mobile', async () => {
      Object.defineProperty(window.navigator, 'userAgent', {
        value: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)',
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(getPDFData).toHaveBeenCalledWith('https://pt.sc.com/mobile/test.pdf');
      });
    });

    it('handles localhost URL replacement', async () => {
      Object.defineProperty(window, 'location', {
        value: { host: 'localhost:3000' },
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(getPDFData).toHaveBeenCalledWith('http://localhost:3000/test.pdf');
      });
    });

    it('downloads KFS PDF', async () => {
      const { container } = render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        const downloadBtn = screen.getByText(CONSTANTS.DownloadBtn);
        fireEvent.click(downloadBtn);
        // Can't actually test the download behavior, but we can verify the click handler was called
      });
    });

    it('scrolls on button click', async () => {
      const mockScrollBy = jest.fn();
      const mockRef = { current: { scrollBy: mockScrollBy } };

      jest.spyOn(React, 'useRef').mockReturnValueOnce(mockRef);

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        const scrollBtn = container.querySelector('.next-arrow footer');
        fireEvent.click(scrollBtn);
        expect(mockScrollBy).toHaveBeenCalledWith({ top: 200, behavior: 'smooth' });
      });
    });
  });

  describe('Stage 1 (Terms and Conditions)', () => {
    it('loads and displays T&C document', async () => {
      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(getPDFData).toHaveBeenCalledWith('https://pt.sc.com/tnc.pdf');
        expect(screen.getByText(CONSTANTS.DownloadHeader)).toBeInTheDocument();
        expect(screen.getAllByText(CONSTANTS.ReadBtn).length).toBeGreaterThan(0);
        expect(screen.getAllByText(CONSTANTS.DownloadBtn).length).toBeGreaterThan(1);
        expect(screen.getByText(CONSTANTS.Remarks)).toBeInTheDocument();
      });
    });

    it('downloads terms PDFs for PIL campaign', async () => {
      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        const downloadLinks = screen.getAllByText(CONSTANTS.DownloadBtn);
        fireEvent.click(downloadLinks[0]); // First PDF
        fireEvent.click(downloadLinks[1]); // Second PDF
        fireEvent.click(downloadLinks[2]); // Third PDF
        // Can't actually test the download behavior, but we can verify the click handlers were called
      });
    });

    it('downloads terms PDFs for CC campaign', async () => {
      // Change the campaign to a credit card one
      const ccMockStore = JSON.parse(JSON.stringify(mockStore));
      ccMockStore.stages.stages[0].stageInfo.products[0].campaign = 'HKSOG20VAWV000';
      ccMockStore.preApproval.formConfigmetaData.products[0].campaign = 'HKSOG20VAWV000';
      
      (useSelector as jest.Mock).mockImplementation((selector) => selector(ccMockStore));

      const ccMockPdfResponse = JSON.parse(JSON.stringify(mockPdfResponse));
      ccMockPdfResponse.data.tncLinkCampaignCode.HKSOG20VAWV000 = [{
        pdfLinks: [
          { Title: 'III. Client Terms', url: 'test1.pdf' },
          { Title: 'III. Credit Card Terms', url: 'test2.pdf' },
          { Title: 'VI. Welcome Offers', url: 'test3.pdf' },
          { Title: 'IX. E-Statement Service', url: 'test4.pdf' },
          { Title: 'X. Points Redemption', url: 'test5.pdf' },
          { Title: 'XI. Credit Card Instalment Plan', url: 'test6.pdf' },
        ],
      }];

      (getData as jest.Mock).mockResolvedValue(ccMockPdfResponse);

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        const downloadLinks = screen.getAllByText(CONSTANTS.DownloadBtn);
        // Click all download links to cover all CC cases
        downloadLinks.forEach(link => fireEvent.click(link));
      });
    });

    it('shows accept button when not visible', async () => {
      render(
        <OnboardingBeforeStart
          isVisible={false}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        const acceptBtn = screen.getByText(CONSTANTS.acceptButton);
        fireEvent.click(acceptBtn);
        expect(mockNextPage).toHaveBeenCalled();
      });
    });

    it('scrolls on button click for stage 1', async () => {
      const mockScrollBy = jest.fn();
      const mockRef = { current: { scrollBy: mockScrollBy } };

      jest.spyOn(React, 'useRef').mockReturnValueOnce(mockRef);

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        const scrollBtn = container.querySelector('.next-arrow footer');
        fireEvent.click(scrollBtn);
        expect(mockScrollBy).toHaveBeenCalledWith({ top: 5000, behavior: 'smooth' });
      });
    });
  });

  describe('Language variations', () => {
    it('renders in Chinese (simplified)', async () => {
      (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('zh');

      render(
        <OnboardingBeforeStart
          isVisible={false}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(screen.getByText(CONSTANTS.acceptButton_CN)).toBeInTheDocument();
      });
    });

    it('renders in Chinese (traditional)', async () => {
      (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('zh-HK');

      render(
        <OnboardingBeforeStart
          isVisible={false}
          onScrollEnd={mockOnScrollEnd}
          stageID={1}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(screen.getByText(CONSTANTS.acceptButton_HK)).toBeInTheDocument();
      });
    });

    it('uses Chinese KFS URL when language is Chinese', async () => {
      (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('zh');

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      await waitFor(() => {
        expect(getData).toHaveBeenCalledWith(expect.stringContaining('_zh'));
      });
    });
  });

  describe('Device detection', () => {
    it('detects iPhone Safari', () => {
      Object.defineProperty(window.navigator, 'userAgent', {
        value: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1',
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      expect(container.querySelector('.iphoneDeviceSafari')).toBeInTheDocument();
    });

    it('detects iPhone non-Safari', () => {
      Object.defineProperty(window.navigator, 'userAgent', {
        value: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148',
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      expect(container.querySelector('.iphoneDevice')).toBeInTheDocument();
    });

    it('detects Android', () => {
      Object.defineProperty(window.navigator, 'userAgent', {
        value: 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.72 Mobile Safari/537.36',
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      expect(container.querySelector('.andriodDevice')).toBeInTheDocument();
    });

    it('detects desktop', () => {
      Object.defineProperty(window.navigator, 'userAgent', {
        value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36',
        writable: true,
      });

      render(
        <OnboardingBeforeStart
          isVisible={true}
          onScrollEnd={mockOnScrollEnd}
          stageID={0}
          nextPage={mockNextPage}
        />
      );

      expect(container.querySelector('.desktopDevice')).toBeInTheDocument();
    });
  });

  it('handles scroll to bottom', async () => {
    const mockRef = { 
      current: { 
        scrollTop: 100,
        scrollHeight: 200,
        clientHeight: 100,
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
      } 
    };

    jest.spyOn(React, 'useRef').mockReturnValueOnce(mockRef);

    render(
      <OnboardingBeforeStart
        isVisible={true}
        onScrollEnd={mockOnScrollEnd}
        stageID={0}
        nextPage={mockNextPage}
      />
    );

    // Simulate scroll event
    const scrollEvent = new Event('scroll');
    Object.defineProperty(mockRef.current, 'scrollTop', { value: 150 });
    fireEvent(mockRef.current, scrollEvent);

    await waitFor(() => {
      expect(mockOnScrollEnd).toHaveBeenCalledWith(false);
    });
  });

  it('replaces history state', () => {
    const mockReplaceState = jest.fn();
    Object.defineProperty(window, 'history', {
      value: { replaceState: mockReplaceState },
      writable: true,
    });

    render(
      <OnboardingBeforeStart
        isVisible={true}
        onScrollEnd={mockOnScrollEnd}
        stageID={0}
        nextPage={mockNextPage}
      />
    );

    expect(mockReplaceState).toHaveBeenCalledWith('', '', '/hk/before-start');
  });
});

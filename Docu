import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import Zoloz from './Zoloz';
import * as services from '../../../services/preApprovalPostServices';
import { CONSTANTS } from '../../../../../utils/common/constants';

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

// Mock the react-redux hooks
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useSelector: jest.fn(),
  useDispatch: jest.fn(),
}));

// Mock the services
jest.mock('../../../services/preApprovalPostServices', () => ({
  postQRCodeZOLO: jest.fn(),
  postZOLOCheck: jest.fn(),
  postZolozAcknowledge: jest.fn(),
  postPdfPreview: jest.fn(),
}));

// Mock other dependencies
jest.mock('../../../../preApproval/services/preApprovalServices', () => ({
  getImagePreview: jest.fn(),
}));

describe('Zoloz Component', () => {
  let useSelectorMock: jest.Mock;
  let useDispatchMock: jest.Mock;
  let dispatchMock: jest.Mock;
  const mockSetHKIDVersion = jest.fn();

  beforeEach(() => {
    useSelectorMock = jest.requireMock('react-redux').useSelector;
    useDispatchMock = jest.requireMock('react-redux').useDispatch;
    dispatchMock = jest.fn();
    useDispatchMock.mockReturnValue(dispatchMock);

    // Reset all mocks
    jest.clearAllMocks();

    // Default mock implementations
    (services.postQRCodeZOLO as jest.Mock).mockResolvedValue({
      status: 200,
      data: { qrCode: 'testQRCode', transactionId: 'test123' }
    });

    (services.postZOLOCheck as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        documents: [{
          docId: 'testDocId',
          documentName: 'testDocument.png',
          documentTypeCode: 'A001',
          documentCategoryCode: 'R0001',
          responseStatus: 'SUCCESS'
        }]
      }
    });

    (services.postZolozAcknowledge as jest.Mock).mockResolvedValue({
      status: 200,
      data: [{ responseStatus: 'Success' }]
    });

    (services.postPdfPreview as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        statusCode: 'OK',
        documents: [{ docId: 'testDocId' }]
      }
    });
  });

  const renderComponent = (customState = {}) => {
    const defaultState = {
      stages: {
        stages: [{
          stageInfo: {
            application: { channel_reference: 'TEST123' },
            applicant_documents: [{
              document_list: [{
                document_category: 'R0001',
                document_options: [{
                  document_types: [{
                    uploaded_documents: []
                  }]
                }]
              }]
            }]
          },
          dynamicDocumentsUpload: {
            showUploadFileSuccess: false,
            HKIDQRCodeData: { qrCode: 'testQRCode', transactionId: 'test123' },
            HKIDVersionValue: 'A001',
            fileSectionData: { document_category: 'R0001' },
            documentCount: 0,
            zoloErrorpopup: false
          }
        }]
      },
      preApproval: {
        imgPrevURL: '',
        documentZoloCheckRes: []
      }
    };

    const finalState = { ...defaultState, ...customState };
    useSelectorMock.mockImplementation((selector) => selector(finalState));

    return render(<Zoloz setHKIDVersion={mockSetHKIDVersion} />);
  };

  it('should render the component with QR code section by default', () => {
    renderComponent();
    expect(screen.getByText(/Colour Identity Proof/i)).toBeInTheDocument();
    expect(screen.getByRole('img', { name: 'ORError' })).toBeInTheDocument();
    expect(screen.getByText(/Submit/i)).toBeInTheDocument();
  });

  it('should render success section when showUploadFileSuccess is true', () => {
    renderComponent({
      stages: {
        stages: [{
          stageInfo: {},
          dynamicDocumentsUpload: {
            showUploadFileSuccess: true
          }
        }]
      },
      preApproval: {
        imgPrevURL: 'testURL',
        documentZoloCheckRes: [{
          docId: 'testDocId',
          documentName: 'testDocument.png'
        }]
      }
    });

    expect(screen.getByText(/Upload complete/i)).toBeInTheDocument();
    expect(screen.getByText(/testDocument.png/i)).toBeInTheDocument();
  });

  it('should call closeFileUpload when close button is clicked', () => {
    renderComponent();
    fireEvent.click(screen.getByText(/Close/i));
    expect(dispatchMock).toHaveBeenCalled();
  });

  it('should call callSubmit when submit button is clicked', async () => {
    renderComponent();
    fireEvent.click(screen.getByText(/Submit/i));
    
    await waitFor(() => {
      expect(services.postZOLOCheck).toHaveBeenCalled();
    });
  });

  it('should show error popup when zoloCheckResponse has no documents', async () => {
    (services.postZOLOCheck as jest.Mock).mockResolvedValue({
      status: 200,
      data: { documents: [] }
    });

    renderComponent();
    fireEvent.click(screen.getByText(/Submit/i));
    
    await waitFor(() => {
      expect(screen.queryByText(/Submit/i)).not.toBeInTheDocument();
    });
  });

  it('should handle API errors in callSubmit', async () => {
    (services.postZOLOCheck as jest.Mock).mockRejectedValue(new Error('API Error'));
    
    renderComponent();
    fireEvent.click(screen.getByText(/Submit/i));

    await waitFor(() => {
      expect(dispatchMock).toHaveBeenCalledWith(expect.objectContaining({
        type: 'error/getError'
      }));
    });
  });

  it('should call okBtnClick and update store when continue is clicked', () => {
    renderComponent({
      stages: {
        stages: [{
          stageInfo: {},
          dynamicDocumentsUpload: {
            showUploadFileSuccess: true
          }
        }]
      },
      preApproval: {
        imgPrevURL: 'testURL',
        documentZoloCheckRes: [{
          docId: 'testDocId',
          documentName: 'testDocument.png',
          documentTypeCode: 'A001',
          documentCategoryCode: 'R0001',
          responseStatus: 'SUCCESS',
          appId: 'TEST123',
          imageOrder: '1',
          applicantId: '1',
          period: 0
        }]
      }
    });

    fireEvent.click(screen.getByText(/Continue/i));
    expect(dispatchMock).toHaveBeenCalledTimes(7); // Verify all expected dispatches
    expect(mockSetHKIDVersion).toHaveBeenCalledWith('');
  });

  it('should disable continue button when showUploadFileSuccess is false', () => {
    renderComponent();
    expect(screen.getByText(/Continue/i)).toBeDisabled();
  });

  it('should enable continue button when showUploadFileSuccess is true', () => {
    renderComponent({
      stages: {
        stages: [{
          stageInfo: {},
          dynamicDocumentsUpload: {
            showUploadFileSuccess: true
          }
        }]
      },
      preApproval: {
        imgPrevURL: 'testURL',
        documentZoloCheckRes: [{
          docId: 'testDocId',
          documentName: 'testDocument.png'
        }]
      }
    });

    expect(screen.getByText(/Continue/i)).not.toBeDisabled();
  });

  it('should show error popup when zoloErrorpopup is true', () => {
    renderComponent({
      stages: {
        stages: [{
          stageInfo: {},
          dynamicDocumentsUpload: {
            zoloErrorpopup: true
          }
        }]
      }
    });

    expect(screen.getByText(/Error/i)).toBeInTheDocument();
  });

  it('should call modelClose and callQRCodeAPI when error popup is closed', async () => {
    renderComponent({
      stages: {
        stages: [{
          stageInfo: {},
          dynamicDocumentsUpload: {
            zoloErrorpopup: true
          }
        }]
      }
    });
    
    fireEvent.click(screen.getByText(/OK/i));

    await waitFor(() => {
      expect(services.postQRCodeZOLO).toHaveBeenCalled();
    });
  });

  it('should render different languages correctly', () => {
    // Mock language setting
    CONSTANTS.LANG_EN = 'en';
    CONSTANTS.LANG_CN = 'zh';
    CONSTANTS.LANG_HK = 'zh-HK';

    // Test English
    renderComponent();
    expect(screen.getByText(/Submit/i)).toBeInTheDocument();

    // Test Chinese (simplified)
    // Would need to mock the language selector to return different values
    // This is simplified for example purposes
  });
});

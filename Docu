import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import DucumentUploadMainSCR from './DocumentUploadMainSCR';
import { postTMXUserSession, postFinalAcknowledge, postDocSaveData, postFulFilmentData } from '../../../../preApproval/services/preApprovalPostServices';
import { CONSTANTS } from '../../../../../utils/common/constants';

// Mock the services and components
jest.mock('../../../../preApproval/services/preApprovalPostServices');
jest.mock('../../../../../services/common-service');
jest.mock('../../../../../utils/common/change.utils');
jest.mock('../documentType/document-type-dynamic', () => () => <div>DocumentTypeDynamic Mock</div>);
jest.mock('../../../../../shared/components/spinner/spinner', () => () => <div>Spinner Mock</div>);
jest.mock('../../../../../shared/components/close/close', () => () => <div>Close Mock</div>);

const mockStore = configureStore([]);

describe('DocumentUploadMainSCR Component', () => {
  let store: any;

  const initialState = {
    stages: {
      stages: [{
        stageId: 'doc-upload',
        stageInfo: {
          applicant_documents: [{
            document_list: [
              {
                document_options: [{
                  document_types: [
                    { uploaded_documents: null },
                    { uploaded_documents: { id: 1 } }
                  ]
                }]
              }
            ]
          }],
          application: {
            channel_reference: 'test-ref'
          },
          products: [{
            product_category: 'CC'
          }]
        }
      }],
      dynamicDocumentsUpload: {
        documentData: {},
        HKIDQRCodeData: null,
        documentCount: 1,
        success: true,
        fileSectionData: null,
        changeIconColorIdentityProof: false
      }
    },
    preApproval: {
      resumeAllowed: 'N',
      currentStage: 'PD-3'
    }
  };

  beforeEach(() => {
    store = mockStore(initialState);
    (postTMXUserSession as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { review_status: 'pass' } 
    });
    (postFinalAcknowledge as jest.Mock).mockResolvedValue({ status: 202 });
    (postDocSaveData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {},
        applicant_documents: {}
      } 
    });
    (postFulFilmentData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {}
      } 
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('renders without crashing', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText('DocumentTypeDynamic Mock')).toBeInTheDocument();
  });

  it('displays document count correctly', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText('1/2')).toBeInTheDocument();
  });

  it('shows continue button when success is true', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByRole('button', { name: /continue/i })).toBeInTheDocument();
  });

  it('disables continue button when not all documents are uploaded', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    const button = screen.getByRole('button', { name: /continue/i });
    expect(button).toBeDisabled();
  });

  it('enables continue button when all documents are uploaded', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    const button = screen.getByRole('button', { name: /continue/i });
    expect(button).not.toBeDisabled();
  });

  it('shows spinner when showSpinner is true and stage is ld-1', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        stages: [{
          ...initialState.stages.stages[0],
          stageId: 'ld-1'
        }]
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText('Spinner Mock')).toBeInTheDocument();
  });

  it('handles resumeAllowed case correctly', () => {
    const customState = {
      ...initialState,
      preApproval: {
        ...initialState.preApproval,
        resumeAllowed: 'Y'
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    // Verify behavior when resumeAllowed is 'Y'
  });

  it('handles nextStage function for CC product', async () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalled();
      expect(postFinalAcknowledge).toHaveBeenCalled();
      expect(postDocSaveData).toHaveBeenCalled();
    });
  });

  it('handles nextStage function for non-CC product', async () => {
    const customState = {
      ...initialState,
      stages: {
        stages: [{
          stageId: 'doc-upload',
          stageInfo: {
            applicant_documents: [{
              document_list: [
                {
                  document_options: [{
                    document_types: [
                      { uploaded_documents: null },
                      { uploaded_documents: { id: 1 } }
                    ]
                  }]
                }
              ]
            }],
            application: {
              channel_reference: 'test-ref'
            },
            products: [{
              product_category: 'LOAN'
            }]
          }
        }],
        dynamicDocumentsUpload: {
          documentData: {},
          HKIDQRCodeData: null,
          documentCount: 2,
          success: true,
          fileSectionData: null,
          changeIconColorIdentityProof: false
        }
      },
      preApproval: {
        resumeAllowed: 'N',
        currentStage: 'PD-3'
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalled();
      expect(postFinalAcknowledge).toHaveBeenCalled();
      expect(postDocSaveData).toHaveBeenCalled();
    });
  });

  it('handles error in postTMXUserSession', async () => {
    (postTMXUserSession as jest.Mock).mockRejectedValue(new Error('API Error'));
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalled();
    });
  });

  it('handles non-pass review_status in postTMXUserSession', async () => {
    (postTMXUserSession as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { review_status: 'fail' } 
    });
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalled();
    });
  });

  it('handles error in postFinalAcknowledge', async () => {
    (postFinalAcknowledge as jest.Mock).mockRejectedValue(new Error('API Error'));
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postFinalAcknowledge).toHaveBeenCalled();
    });
  });

  it('handles non-202 status in postFinalAcknowledge', async () => {
    (postFinalAcknowledge as jest.Mock).mockResolvedValue({ status: 400 });
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postFinalAcknowledge).toHaveBeenCalled();
    });
  });

  it('handles error in postDocSaveData', async () => {
    (postDocSaveData as jest.Mock).mockRejectedValue(new Error('API Error'));
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postDocSaveData).toHaveBeenCalled();
    });
  });

  it('handles hard stop response from postDocSaveData', async () => {
    (postDocSaveData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'HARD', 
          response_action: 'STOP' 
        } 
      } 
    });
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postDocSaveData).toHaveBeenCalled();
    });
  });

  it('handles error in postFulFilmentData', async () => {
    (postFulFilmentData as jest.Mock).mockRejectedValue(new Error('API Error'));
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postFulFilmentData).toHaveBeenCalled();
    });
  });

  it('handles non-200 status in postFulFilmentData', async () => {
    (postFulFilmentData as jest.Mock).mockResolvedValue({ status: 400 });
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postFulFilmentData).toHaveBeenCalled();
    });
  });

  it('handles hard stop response from postFulFilmentData', async () => {
    (postFulFilmentData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'HARD', 
          response_action: 'STOP' 
        } 
      } 
    });
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postFulFilmentData).toHaveBeenCalled();
    });
  });

  it('renders correctly when fileSectionData is not null', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          fileSectionData: { someData: true }
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    expect(screen.getByText('DocumentTypeDynamic Mock')).toBeInTheDocument();
  });

  it('renders correctly when success is false', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          success: false
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    expect(screen.queryByRole('button', { name: /continue/i })).not.toBeInTheDocument();
  });
});

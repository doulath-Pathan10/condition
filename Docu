import React from 'react';
import { render, fireEvent, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import Dates from './Dates';
import { KeyWithAnyModel } from '../../../utils/model/common-model';

// Mock the validation service
jest.mock('../../../services/validation-service', () => ({
  allowOnlyCharacter: jest.fn(),
  isValidDate: jest.fn().mockImplementation(() => true),
  calculateAge: jest.fn().mockImplementation(() => 25),
  calculateMonth: jest.fn().mockImplementation(() => true)
}));

// Mock the utility functions
jest.mock('../../../utils/common/change.utils', () => ({
  getUrl: {
    getLanguageInfo: jest.fn().mockReturnValue('en'),
    getParameterByName: jest.fn().mockReturnValue('resume')
  },
  fieldError: jest.fn().mockReturnValue(false),
  isFieldUpdate: jest.fn(),
  fieldIdAppend: jest.fn().mockImplementation((props) => props.data.logical_field_name)
}));

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

describe('Dates Component', () => {
  const baseProps: KeyWithAnyModel = {
    data: {
      logical_field_name: 'date_of_birth',
      rwb_label_name: 'Date of Birth',
      mandatory: 'Yes',
      editable: false
    },
    handleCallback: jest.fn(),
    handleFieldDispatch: jest.fn()
  };

  const initialState = {
    stages: {
      stages: [
        {
          stageId: 'pd-1',
          stageInfo: {
            applicants: [{
              date_of_birth_a_1: '1995-05-15',
              expiry_date_a_1: '2025-12-31',
              id_type_cb: 'Passport',
              work_type: 'E001',
              work_type_a_1: 'E001'
            }],
            products: [{
              product_category: 'PL'
            }]
          }
        }
      ],
      userInput: {
        applicants: [{
          date_of_birth: '1995-05-15',
          expiry_date: '2025-12-31'
        }]
      }
    },
    fielderror: {
      error: []
    },
    preApproval: {
      resumeAllowed: 'Y'
    },
    lastAccessed: {},
    age: {},
    continueValidation: {}
  };

  let store: any;

  beforeEach(() => {
    store = mockStore(initialState);
    jest.clearAllMocks();
  });

  test('renders date inputs with correct initial values', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    expect(screen.getByPlaceholderText('DD')).toHaveValue('15');
    expect(screen.getByPlaceholderText('MM')).toHaveValue('05');
    expect(screen.getByPlaceholderText('YYYY')).toHaveValue('1995');
  });

  test('handles DD input change and moves focus to MM', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    const mmInput = screen.getByPlaceholderText('MM');

    fireEvent.change(ddInput, { target: { value: '20' } });
    expect(ddInput).toHaveValue('20');
    expect(mmInput).toHaveFocus();
  });

  test('handles MM input change and moves focus to YYYY when valid', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const mmInput = screen.getByPlaceholderText('MM');
    const yyyyInput = screen.getByPlaceholderText('YYYY');

    fireEvent.change(mmInput, { target: { value: '12' } });
    expect(mmInput).toHaveValue('12');
    expect(yyyyInput).toHaveFocus();
  });

  test('shows error for invalid month (>12)', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const mmInput = screen.getByPlaceholderText('MM');
    fireEvent.change(mmInput, { target: { value: '13' } });
    
    expect(screen.getByText(/Date is not valid/)).toBeInTheDocument();
  });

  test('shows error for empty mandatory field', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.change(ddInput, { target: { value: '' } });
    fireEvent.blur(ddInput);
    
    expect(screen.getByText(/Date of Birth is required/)).toBeInTheDocument();
  });

  test('shows error for invalid leap year date', () => {
    // Mock isValidDate to return false for leap year scenario
    require('../../../services/validation-service').isValidDate.mockReturnValueOnce(false);
    
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.change(ddInput, { target: { value: '30' } });
    const mmInput = screen.getByPlaceholderText('MM');
    fireEvent.change(mmInput, { target: { value: '02' } });
    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2020' } });
    
    expect(screen.getByText(/Date is not valid/)).toBeInTheDocument();
  });

  test('handles expiry date validation', () => {
    const expiryProps = {
      ...baseProps,
      data: {
        ...baseProps.data,
        logical_field_name: 'expiry_date',
        rwb_label_name: 'Expiry Date'
      }
    };

    render(
      <Provider store={store}>
        <Dates {...expiryProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.change(ddInput, { target: { value: '31' } });
    const mmInput = screen.getByPlaceholderText('MM');
    fireEvent.change(mmInput, { target: { value: '12' } });
    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2025' } });
    
    expect(expiryProps.handleCallback).toHaveBeenCalled();
  });

  test('shows error for expiry date in past', () => {
    const expiryProps = {
      ...baseProps,
      data: {
        ...baseProps.data,
        logical_field_name: 'expiry_date',
        rwb_label_name: 'Expiry Date'
      }
    };

    // Mock current date to be after the test expiry date
    jest.spyOn(global, 'Date').mockImplementation(() => new Date('2026-01-01') as unknown as string);

    render(
      <Provider store={store}>
        <Dates {...expiryProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.change(ddInput, { target: { value: '31' } });
    const mmInput = screen.getByPlaceholderText('MM');
    fireEvent.change(mmInput, { target: { value: '12' } });
    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2025' } });
    
    expect(screen.getByText(/Expiry Date must be in the future/)).toBeInTheDocument();

    // Restore original Date
    jest.restoreAllMocks();
  });

  test('validates business establishment date', () => {
    const businessProps = {
      ...baseProps,
      data: {
        ...baseProps.data,
        logical_field_name: 'business_est_date',
        rwb_label_name: 'Business Establishment Date'
      }
    };

    render(
      <Provider store={store}>
        <Dates {...businessProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.change(ddInput, { target: { value: '01' } });
    const mmInput = screen.getByPlaceholderText('MM');
    fireEvent.change(mmInput, { target: { value: '01' } });
    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2010' } });
    
    expect(businessProps.handleCallback).toHaveBeenCalled();
  });

  test('shows error for business date in future', () => {
    const businessProps = {
      ...baseProps,
      data: {
        ...baseProps.data,
        logical_field_name: 'business_est_date',
        rwb_label_name: 'Business Establishment Date'
      }
    };

    // Mock current date
    const realDate = Date;
    global.Date = class extends realDate {
      constructor() {
        super();
        return new realDate('2020-01-01');
      }
    } as any;

    render(
      <Provider store={store}>
        <Dates {...businessProps} />
      </Provider>
    );

    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2025' } });
    
    expect(screen.getByText(/Business Establishment Date cannot be in the future/)).toBeInTheDocument();

    // Restore original Date
    global.Date = realDate;
  });

  test('displays tick mark when date is valid', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.change(ddInput, { target: { value: '15' } });
    const mmInput = screen.getByPlaceholderText('MM');
    fireEvent.change(mmInput, { target: { value: '05' } });
    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '1995' } });
    
    expect(document.querySelector('.tick-class')).toBeInTheDocument();
  });

  test('handles tab key press with validation', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const ddInput = screen.getByPlaceholderText('DD');
    fireEvent.keyDown(ddInput, { key: 'Tab', code: 'Tab' });
    
    expect(screen.getByText(/Date of Birth is required/)).toBeInTheDocument();
  });

  test('does not render when workType is S103 in pd-1 stage', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        stages: [{
          ...initialState.stages.stages[0],
          stageInfo: {
            ...initialState.stages.stages[0].stageInfo,
            applicants: [{
              ...initialState.stages.stages[0].stageInfo.applicants[0],
              work_type: 'S103'
            }]
          }
        }]
      }
    };

    store = mockStore(customState);

    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    expect(screen.queryByPlaceholderText('DD')).not.toBeInTheDocument();
  });

  test('renders for workType E002 in ad-2 stage', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        stages: [{
          ...initialState.stages.stages[0],
          stageId: 'ad-2',
          stageInfo: {
            ...initialState.stages.stages[0].stageInfo,
            applicants: [{
              ...initialState.stages.stages[0].stageInfo.applicants[0],
              work_type: 'E002'
            }]
          }
        }]
      }
    };

    store = mockStore(customState);

    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    expect(screen.getByPlaceholderText('DD')).toBeInTheDocument();
  });

  test('handles date picker change', () => {
    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const datePicker = screen.getByTestId('date-picker');
    fireEvent.change(datePicker, { target: { value: '1995-05-20' } });
    
    expect(baseProps.handleCallback).toHaveBeenCalledWith(
      baseProps.data,
      '1995-05-20'
    );
  });

  test('shows error when age is below minimum for PL product', () => {
    require('../../../services/validation-service').calculateAge.mockReturnValueOnce(19);

    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2005' } });
    
    expect(screen.getByText(/Minimum age for this product is 20/)).toBeInTheDocument();
  });

  test('shows error when age is below minimum for non-PL product', () => {
    const nonPLState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        stages: [{
          ...initialState.stages.stages[0],
          stageInfo: {
            ...initialState.stages.stages[0].stageInfo,
            products: [{
              product_category: 'NON-PL'
            }]
          }
        }]
      }
    };

    store = mockStore(nonPLState);
    require('../../../services/validation-service').calculateAge.mockReturnValueOnce(17);

    render(
      <Provider store={store}>
        <Dates {...baseProps} />
      </Provider>
    );

    const yyyyInput = screen.getByPlaceholderText('YYYY');
    fireEvent.change(yyyyInput, { target: { value: '2007' } });
    
    expect(screen.getByText(/Minimum age for this product is 18/)).toBeInTheDocument();
  });
});

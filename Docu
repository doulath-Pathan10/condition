import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import DucumentUploadMainSCR from './DucumentUploadMainSCR';
import { CONSTANTS } from '../../../../../utils/common/constants';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

// Mock child components to simplify testing
jest.mock('../documentType/document-type-dynamic', () => () => (
  <div>DocumentTypeDynamic Mock</div>
));

jest.mock('../../../../../shared/components/spinner/spinner', () => () => (
  <div data-testid="spinner">Spinner Mock</div>
));

jest.mock('../../../../../shared/components/close/close', () => () => (
  <div>Close Mock</div>
));

describe('DocumentUploadMainSCR Component', () => {
  let store: any;

  const baseState = {
    stages: {
      stages: [
        {
          stageId: 'ld-1',
          stageInfo: {
            application: {
              channel_reference: 'test123'
            },
            products: [
              {
                product_category: 'CC'
              }
            ],
            applicant_documents: [
              {
                document_list: [
                  {
                    document_options: [
                      {
                        document_types: [
                          {
                            uploaded_documents: null
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        }
      ],
      dynamicDocumentsUpload: {
        documentData: {},
        HKIDQRCodeData: null,
        changeIconColorIdentityProof: false,
        documentCount: 0,
        success: true,
        fileSectionData: null
      }
    },
    preApproval: {
      resumeAllowed: 'N',
      currentStage: 'PD-1'
    }
  };

  beforeEach(() => {
    // Mock external utility functions
    jest.spyOn(require('../../../../../utils/common/change.utils'), 'getLanguageInfo')
      .mockReturnValue(CONSTANTS.LANG_EN);
    jest.spyOn(require('../../../../../utils/common/change.utils'), 'getParameterByName')
      .mockReturnValue(null);

    store = mockStore(baseState);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('renders the basic layout', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.getByText('Please provide the following documents')).toBeInTheDocument();
    expect(screen.getByText('Upload documents')).toBeInTheDocument();
    expect(screen.getByText('0/1')).toBeInTheDocument();
    expect(screen.getByText('DocumentTypeDynamic Mock')).toBeInTheDocument();
  });

  it('shows spinner when showSpinner is true and stage is ld-1', () => {
    // Update the store to trigger spinner
    const customStore = mockStore({
      ...baseState,
      stages: {
        ...baseState.stages,
        stages: [{ ...baseState.stages.stages[0], stageId: 'ld-1' }]
      }
    });

    render(
      <Provider store={customStore}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  it('disables continue button when not all documents are uploaded', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    expect(continueButton).toBeDisabled();
  });

  it('enables continue button when all documents are uploaded', () => {
    const customStore = mockStore({
      ...baseState,
      stages: {
        ...baseState.stages,
        dynamicDocumentsUpload: {
          ...baseState.stages.dynamicDocumentsUpload,
          documentCount: 1
        }
      }
    });

    render(
      <Provider store={customStore}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    expect(continueButton).not.toBeDisabled();
  });

  it('handles resume allowed flow', () => {
    const customStore = mockStore({
      ...baseState,
      preApproval: {
        ...baseState.preApproval,
        resumeAllowed: 'Y'
      }
    });

    render(
      <Provider store={customStore}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    // Add specific assertions for resume flow
    expect(screen.getByText('DocumentTypeDynamic Mock')).toBeInTheDocument();
  });

  it('handles resume page parameter', () => {
    jest.spyOn(require('../../../../../utils/common/change.utils'), 'getParameterByName')
      .mockReturnValue('resume');

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    // Add specific assertions for resume page
    expect(screen.getByText('DocumentTypeDynamic Mock')).toBeInTheDocument();
  });

  it('renders different language versions', () => {
    jest.spyOn(require('../../../../../utils/common/change.utils'), 'getLanguageInfo')
      .mockReturnValue(CONSTANTS.LANG_CN);

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    // Add assertions for Chinese text if needed
    expect(screen.getByText('DocumentTypeDynamic Mock')).toBeInTheDocument();
  });

  it('does not render footer when fileSectionData exists', () => {
    const customStore = mockStore({
      ...baseState,
      stages: {
        ...baseState.stages,
        dynamicDocumentsUpload: {
          ...baseState.stages.dynamicDocumentsUpload,
          fileSectionData: { some: 'data' }
        }
      }
    });

    render(
      <Provider store={customStore}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.queryByText('Note:')).not.toBeInTheDocument();
    expect(screen.queryByRole('button', { name: /continue/i })).not.toBeInTheDocument();
  });
});

describe('API Interaction Tests', () => {
  let store: any;

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageId: 'ld-1',
            stageInfo: {
              application: {
                channel_reference: 'test123'
              },
              products: [
                {
                  product_category: 'CC'
                }
              ],
              applicant_documents: [
                {
                  document_list: [
                    {
                      document_options: [
                        {
                          document_types: [
                            {
                              uploaded_documents: null
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          }
        ],
        dynamicDocumentsUpload: {
          documentData: {},
          HKIDQRCodeData: null,
          changeIconColorIdentityProof: false,
          documentCount: 1, // All documents uploaded
          success: true,
          fileSectionData: null
        }
      },
      preApproval: {
        resumeAllowed: 'N',
        currentStage: 'PD-1'
      }
    });

    jest.spyOn(require('../../../../../utils/common/change.utils'), 'getLanguageInfo')
      .mockReturnValue(CONSTANTS.LANG_EN);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('calls nextStage when continue button is clicked', async () => {
    // Mock API responses
    jest.spyOn(require('../../../../preApproval/services/preApprovalPostServices'), 'postTMXUserSession')
      .mockResolvedValue({ status: 200, data: { review_status: 'pass' } });
    jest.spyOn(require('../../../../preApproval/services/preApprovalPostServices'), 'postFinalAcknowledge')
      .mockResolvedValue({ status: 202 });
    jest.spyOn(require('../../../../preApproval/services/preApprovalPostServices'), 'postDocSaveData')
      .mockResolvedValue({ 
        status: 200, 
        data: { 
          application: { 
            response_type: 'INFO', 
            response_action: 'CONTINUE' 
          },
          applicants: [],
          applicant_documents: []
        } 
      });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    // Verify loading state
    expect(store.getActions()).toContainEqual(
      expect.objectContaining({
        type: 'common/dispatchLoader',
        payload: true
      })
    );
  });

  it('handles API errors in nextStage', async () => {
    jest.spyOn(require('../../../../preApproval/services/preApprovalPostServices'), 'postTMXUserSession')
      .mockRejectedValue(new Error('API Error'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    // Verify error action was dispatched
    const actions = store.getActions();
    expect(actions).toContainEqual(
      expect.objectContaining({
        type: 'error/getError',
        payload: {
          statusCode: 'error',
          statusText: 'no response'
        }
      })
    );
  });
});

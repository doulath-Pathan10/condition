import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import DucumentUploadMainSCR from './DucumentUploadMainSCR';
import { CONSTANTS } from '../../../../../utils/common/constants';
import { postTMXUserSession, postFinalAcknowledge, postDocSaveData, postFulFilmentData } from '../../../../preApproval/services/preApprovalPostServices';

// Mock the services
jest.mock('../../../../preApproval/services/preApprovalPostServices', () => ({
  postTMXUserSession: jest.fn(),
  postFinalAcknowledge: jest.fn(),
  postDocSaveData: jest.fn(),
  postFulFilmentData: jest.fn(),
}));

// Mock the store
const mockStore = configureStore([]);

describe('DucumentUploadMainSCR Component', () => {
  let store;

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageId: 'ld-1',
            stageInfo: {
              applicant_documents: [
                {
                  document_list: [
                    { id: 1, name: 'Document 1' },
                    { id: 2, name: 'Document 2' },
                  ],
                },
              ],
              application: {
                channel_reference: '12345',
              },
              products: [
                {
                  product_category: 'CC',
                },
              ],
            },
          },
        ],
        dynamicDocumentsUpload: {
          documentData: {},
          HKIDQRCodeData: null,
          changeIconColorIdentityProof: false,
          documentCount: 1,
          success: true,
          fileSectionData: null,
        },
      },
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders without crashing', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText(/Please upload the following documents:/i)).toBeInTheDocument();
  });

  test('renders spinner when showSpinner is true', () => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageId: 'ld-1',
            stageInfo: {
              applicant_documents: [
                {
                  document_list: [
                    { id: 1, name: 'Document 1' },
                    { id: 2, name: 'Document 2' },
                  ],
                },
              ],
              application: {
                channel_reference: '12345',
              },
              products: [
                {
                  product_category: 'CC',
                },
              ],
            },
          },
        ],
        dynamicDocumentsUpload: {
          documentData: {},
          HKIDQRCodeData: null,
          changeIconColorIdentityProof: false,
          documentCount: 1,
          success: true,
          fileSectionData: null,
        },
      },
    });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  test('calls nextStage and updates stage on successful postTMXUserSession and postFinalAcknowledge', async () => {
    postTMXUserSession.mockResolvedValueOnce({
      status: 200,
      data: { review_status: 'pass' },
    });

    postFinalAcknowledge.mockResolvedValueOnce({
      status: 202,
    });

    postDocSaveData.mockResolvedValueOnce({
      status: 200,
      data: {
        application: {
          response_type: 'INFO',
          response_action: 'SUCCESS',
        },
        applicants: [],
      },
    });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    fireEvent.click(screen.getByText(/Continue/i));

    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalledWith('12345');
      expect(postFinalAcknowledge).toHaveBeenCalledWith('12345');
      expect(postDocSaveData).toHaveBeenCalled();
    });
  });

  test('handles error in nextStage when postTMXUserSession fails', async () => {
    postTMXUserSession.mockRejectedValueOnce(new Error('Failed to fetch'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    fireEvent.click(screen.getByText(/Continue/i));

    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalledWith('12345');
      expect(screen.getByText(/no response/i)).toBeInTheDocument();
    });
  });

  test('handles error in nextStage when postFinalAcknowledge fails', async () => {
    postTMXUserSession.mockResolvedValueOnce({
      status: 200,
      data: { review_status: 'pass' },
    });

    postFinalAcknowledge.mockRejectedValueOnce(new Error('Failed to fetch'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    fireEvent.click(screen.getByText(/Continue/i));

    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalledWith('12345');
      expect(postFinalAcknowledge).toHaveBeenCalledWith('12345');
      expect(screen.getByText(/no response/i)).toBeInTheDocument();
    });
  });

  test('handles error in nextStage when postDocSaveData fails', async () => {
    postTMXUserSession.mockResolvedValueOnce({
      status: 200,
      data: { review_status: 'pass' },
    });

    postFinalAcknowledge.mockResolvedValueOnce({
      status: 202,
    });

    postDocSaveData.mockRejectedValueOnce(new Error('Failed to fetch'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    fireEvent.click(screen.getByText(/Continue/i));

    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalledWith('12345');
      expect(postFinalAcknowledge).toHaveBeenCalledWith('12345');
      expect(postDocSaveData).toHaveBeenCalled();
      expect(screen.getByText(/no response/i)).toBeInTheDocument();
    });
  });

  test('calls postFulFilment and updates stage on successful postFulFilmentData', async () => {
    postTMXUserSession.mockResolvedValueOnce({
      status: 200,
      data: { review_status: 'pass' },
    });

    postFinalAcknowledge.mockResolvedValueOnce({
      status: 202,
    });

    postDocSaveData.mockResolvedValueOnce({
      status: 200,
      data: {
        application: {
          response_type: 'INFO',
          response_action: 'SUCCESS',
        },
        applicants: [],
      },
    });

    postFulFilmentData.mockResolvedValueOnce({
      status: 200,
      data: {
        application: {
          response_type: 'INFO',
          response_action: 'SUCCESS',
        },
        applicants: [],
      },
    });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    fireEvent.click(screen.getByText(/Continue/i));

    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalledWith('12345');
      expect(postFinalAcknowledge).toHaveBeenCalledWith('12345');
      expect(postDocSaveData).toHaveBeenCalled();
      expect(postFulFilmentData).toHaveBeenCalled();
    });
  });

  test('handles error in postFulFilment when postFulFilmentData fails', async () => {
    postTMXUserSession.mockResolvedValueOnce({
      status: 200,
      data: { review_status: 'pass' },
    });

    postFinalAcknowledge.mockResolvedValueOnce({
      status: 202,
    });

    postDocSaveData.mockResolvedValueOnce({
      status: 200,
      data: {
        application: {
          response_type: 'INFO',
          response_action: 'SUCCESS',
        },
        applicants: [],
      },
    });

    postFulFilmentData.mockRejectedValueOnce(new Error('Failed to fetch'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    fireEvent.click(screen.getByText(/Continue/i));

    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalledWith('12345');
      expect(postFinalAcknowledge).toHaveBeenCalledWith('12345');
      expect(postDocSaveData).toHaveBeenCalled();
      expect(postFulFilmentData).toHaveBeenCalled();
      expect(screen.getByText(/no response/i)).toBeInTheDocument();
    });
  });
});

import axios from 'axios';
import { 
  dispatchError, 
  dispatchLoader, 
  getLovData, 
  postRequest, 
  lovRequests,
  gbaGenerate,
  gbaVerify,
  ibankEncrypt,
  ibankRegisterUserData,
  aofDownload,
  preserveRequest,
  resumeRequest,
  addressSearchRequest,
  asiaMilesJson,
  checkProductDetails
} from './your-utility-file';
import { store } from '../utils/store/store';
import { getUrl } from '../utils/common/change.utils';
import { CONSTANTS } from '../utils/common/constants';
import { ibankEncryptMock, ibankRegisterUserDataMock } from '../assets/_mock-data/authorize-mock';

// Mock modules
jest.mock('axios');
jest.mock('../utils/common/change.utils');
jest.mock('../utils/store/store');
jest.mock('./submit-service');
jest.mock('../modules/preApproval/services/preApprovalServices');

describe('Utility Functions', () => {
  const mockDispatch = jest.fn();
  const mockStore = {
    getState: jest.fn(),
    dispatch: mockDispatch
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (store.dispatch as jest.Mock) = mockDispatch;
    (store.getState as jest.Mock) = mockStore.getState;
  });

  describe('dispatchError', () => {
    it('should dispatch error with response data when available', () => {
      const error = {
        response: {
          status: 404,
          statusText: 'Not Found'
        }
      };
      dispatchError(error)(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function));
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'loader/getState',
          payload: { isFetching: false }
        })
      );
    });

    it('should dispatch default error when no response', () => {
      const error = {};
      dispatchError(error)(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'error/getError',
          payload: {
            statusCode: "error",
            statusText: "no response"
          }
        })
      );
    });
  });

  describe('dispatchLoader', () => {
    it('should dispatch loader action with true', () => {
      dispatchLoader(true)(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'loader/getState',
          payload: { isFetching: true }
        })
      );
    });

    it('should dispatch loader action with false', () => {
      dispatchLoader(false)(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'loader/getState',
          payload: { isFetching: false }
        })
      );
    });
  });

  describe('getLovData', () => {
    it('should fetch LOV data without search key', async () => {
      const mockResponse = { data: [{ CODE_DESC: 'Test', CODE_VALUE: '1' }] };
      (axios.get as jest.Mock).mockResolvedValue(mockResponse);
      
      await getLovData('testField')(mockDispatch);
      
      expect(axios.get).toHaveBeenCalled();
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'lov/getLovData',
          payload: {
            label: 'testField',
            value: mockResponse.data
          }
        })
      );
    });

    it('should fetch LOV data with search key', async () => {
      const mockResponse = { data: [{ CODE_DESC: 'Test', CODE_VALUE: '1' }] };
      (axios.get as jest.Mock).mockResolvedValue(mockResponse);
      
      await getLovData('testField', 'searchTerm')(mockDispatch);
      
      expect(axios.get).toHaveBeenCalledWith(expect.stringContaining('q=searchTerm'));
    });

    it('should handle error when fetching LOV data', async () => {
      const mockError = new Error('Failed');
      (axios.get as jest.Mock).mockRejectedValue(mockError);
      
      await expect(getLovData('testField')(mockDispatch)).rejects.toEqual(mockError.response);
    });
  });

  describe('postRequest', () => {
    const mockData = {
      stageInfo: {},
      fieldMetaData: { data: { stages: [] } }
    };
    const mockCurrentStageFields = [];
    const mockCurrentStageId = 'ssf-1';

    beforeEach(() => {
      (getUrl.getChannelRefNo as jest.Mock).mockReturnValue({
        channelRefNo: 'test123',
        applicationRefNo: 'app123'
      });
    });

    it('should make create request for ssf-1 stage', async () => {
      (axios.post as jest.Mock).mockResolvedValue({ 
        status: 200,
        data: { 
          application: { 
            application_reference: 'newRef',
            journey_type: 'testJourney'
          } 
        }
      });
      
      await postRequest(mockData, mockCurrentStageFields, mockCurrentStageId, null)(mockDispatch);
      
      expect(axios.post).toHaveBeenCalled();
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'stages/updateStageId'
        })
      );
    });

    it('should handle AD_3 stage without API call', async () => {
      await postRequest(mockData, mockCurrentStageFields, CONSTANTS.STAGE_NAMES.AD_3, 'testJourney')(mockDispatch);
      expect(axios.post).not.toHaveBeenCalled();
    });

    it('should handle API error', async () => {
      const mockError = new Error('Failed');
      (axios.post as jest.Mock).mockRejectedValue(mockError);
      
      await expect(
        postRequest(mockData, mockCurrentStageFields, mockCurrentStageId, null)(mockDispatch)
      ).rejects.toEqual(mockError.response);
    });
  });

  describe('lovRequests', () => {
    const mockRes = {
      fieldMetaData: {
        data: {
          stages: [{
            fields: [
              { logical_field_name: 'field1', lov: 'Yes', rwb_category: 'bd-1', component_type: 'Text' },
              { logical_field_name: 'field2', lov: 'No', rwb_category: 'bd-1' }
            ]
          }]
        }
      }
    };

    it('should dispatch LOV requests for fields with lov=Yes', async () => {
      await lovRequests(mockRes, 'bd-1')(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function));
    });

    it('should handle resume flag scenario', async () => {
      const mockResWithApplicants = {
        ...mockRes,
        applicants: [{ field1: 'value1' }]
      };
      await lovRequests(mockResWithApplicants, 'bd-1', null, true)(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function));
    });
  });

  describe('gbaGenerate', () => {
    it('should make gba generate request', async () => {
      const mockData = { test: 'data' };
      const mockResponse = { data: 'success' };
      (axios.post as jest.Mock).mockResolvedValue(mockResponse);
      
      const result = await gbaGenerate(mockData)(mockDispatch);
      expect(result).toEqual(mockResponse.data);
      expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'loader/getState'
      }));
    });
  });

  describe('ibankEncrypt', () => {
    const mockUserInput = {
      applicants: [{
        password_a_1: 'test123',
        reconfirm_password: 'test123'
      }]
    };

    it('should handle successful encryption', async () => {
      (axios.post as jest.Mock).mockResolvedValue({ data: ibankEncryptMock });
      
      const result = await ibankEncrypt(mockUserInput)(mockDispatch);
      expect(result).toBeDefined();
      expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'stages/modifyStage'
      }));
    });

    it('should handle encryption error', async () => {
      (axios.post as jest.Mock).mockRejectedValue({ data: ibankEncryptMock });
      
      const result = await ibankEncrypt(mockUserInput)(mockDispatch);
      expect(result).toBeDefined();
    });
  });

  describe('aofDownload', () => {
    it('should download AOF document', async () => {
      const mockBlob = new Blob(['test'], { type: 'application/pdf' });
      (axios.get as jest.Mock).mockResolvedValue({ 
        status: 200,
        data: mockBlob 
      });
      
      await aofDownload()(mockDispatch);
      expect(axios.get).toHaveBeenCalled();
    });
  });

  describe('checkProductDetails', () => {
    it('should return true for CA product', () => {
      const products = [{ product_category: 'CA' }];
      expect(checkProductDetails(products)).toBe(true);
    });

    it('should return false for CC product', () => {
      const products = [{ product_category: 'CC' }];
      expect(checkProductDetails(products)).toBe(false);
    });

    it('should handle multiple products', () => {
      const products = [
        { product_category: 'CA' },
        { product_category: 'CC' }
      ];
      expect(checkProductDetails(products)).toBe(true);
    });
  });

  describe('asiaMilesJson', () => {
    it('should fetch Asia Miles data', async () => {
      const mockResponse = { status: 200, data: {} };
      (axios.get as jest.Mock).mockResolvedValue(mockResponse);
      
      const result = await asiaMilesJson();
      expect(result).toEqual(mockResponse);
    });
  });

  describe('resumeRequest', () => {
    it('should fetch resume data', async () => {
      const mockResponse = { 
        status: 200, 
        data: { 
          application: { 
            channel_reference: 'test123' 
          } 
        } 
      };
      (axios.get as jest.Mock).mockResolvedValue(mockResponse);
      
      await resumeRequest('app123')(mockDispatch);
      expect(mockDispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'urlParam/getAuthorize'
        })
      );
    });
  });

  describe('addressSearchRequest', () => {
    it('should fetch address data', async () => {
      global.fetch = jest.fn(() =>
        Promise.resolve({
          text: () => Promise.resolve('<test>mock</test>'),
          headers: new Headers(),
          ok: true,
          redirected: false,
          status: 200,
          statusText: 'OK',
          type: 'basic',
          url: ''
        })
      ) as jest.Mock;
      
      const result = await addressSearchRequest('test query')(mockDispatch);
      expect(result).toBeDefined();
    });
  });
});

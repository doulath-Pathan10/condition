import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import DucumentUploadMainSCR from './DocumentUploadMainSCR';
import { CONSTANTS } from '../../../../../utils/common/constants';
import { postDocSaveData, postFinalAcknowledge, postFulFilmentData, postTMXUserSession } from '../../../../preApproval/services/preApprovalPostServices';

// Mock the services and utilities
jest.mock('../../../../preApproval/services/preApprovalPostServices');
jest.mock('../../../../../services/common-service');
jest.mock('../../../../../utils/common/change.utils');

const mockStore = configureStore([]);

describe('Additional DocumentUploadMainSCR Tests', () => {
  let store: any;
  const initialState = {
    stages: {
      stages: [{
        stageId: 'ld-1',
        stageInfo: {
          applicant_documents: [{
            document_list: [
              {
                document_options: [{
                  document_types: [
                    { uploaded_documents: null },
                    { uploaded_documents: { id: 1 } }
                  ]
                }]
              }
            ]
          }],
          application: {
            channel_reference: 'test-ref'
          },
          products: [{
            product_category: 'CC'
          }]
        }
      }],
      dynamicDocumentsUpload: {
        documentData: {},
        HKIDQRCodeData: null,
        documentCount: 1,
        success: true,
        fileSectionData: null,
        changeIconColorIdentityProof: false
      }
    },
    preApproval: {
      resumeAllowed: 'N',
      currentStage: 'PD-1'
    }
  };

  beforeEach(() => {
    store = mockStore(initialState);
    (postTMXUserSession as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { review_status: 'pass' } 
    });
    (postFinalAcknowledge as jest.Mock).mockResolvedValue({ status: 202 });
    (postDocSaveData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {},
        applicant_documents: []
      } 
    });
    (postFulFilmentData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {}
      } 
    });
    (require('../../../../../services/common-service').dispatchLoader as jest.Mock).mockReturnValue({ type: 'LOADER_ACTION' });
    (require('../../../../../utils/common/change.utils').getUrl.getParameterByName as jest.Mock).mockReturnValue(null);
    (require('../../../../../utils/common/change.utils').getUrl.getLanguageInfo as jest.Mock).mockReturnValue(CONSTANTS.LANG_EN);
  });

  // Test cases for different stage IDs
  it('renders correctly when stageId is ff-1', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        stages: [{
          ...initialState.stages.stages[0],
          stageId: 'ff-1'
        }]
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    expect(screen.getByText('Provide documents')).toBeInTheDocument();
  });

  // Test case for when fileSectionData is not null
  it('does not render document count when fileSectionData exists', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          fileSectionData: { someData: true }
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    expect(screen.queryByText(/\/\d+/)).not.toBeInTheDocument();
  });

  // Test case for when success is false
  it('does not render continue button when success is false', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          success: false
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    expect(screen.queryByText('Continue')).not.toBeInTheDocument();
  });

  // Test case for HKIDVersion state
  it('applies correct class when HKIDVersion is set', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // The initial class should include "document-view"
    const container = screen.getByText('Provide documents').closest('div');
    expect(container).toHaveClass('document-view');
  });

  // Test case for changeIconColorIdentityProof
  it('handles changeIconColorIdentityProof from state', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          changeIconColorIdentityProof: true
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // This is testing that the component properly uses this prop from state
    // You might need to adjust based on how it's actually used in your component
    expect(store.getState().stages.dynamicDocumentsUpload.changeIconColorIdentityProof).toBe(true);
  });

  // Test case for when postFinalAcknowledge fails
  it('handles postFinalAcknowledge failure', async () => {
    (postFinalAcknowledge as jest.Mock).mockRejectedValue(new Error('API error'));
    
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(store.getActions()).toContainEqual({
        type: 'error/getError',
        payload: {
          statusCode: 'error',
          statusText: 'no response'
        }
      });
    });
  });

  // Test case for when postDocSaveData fails
  it('handles postDocSaveData failure', async () => {
    (postDocSaveData as jest.Mock).mockRejectedValue(new Error('API error'));
    
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(store.getActions()).toContainEqual({
        type: 'error/getError',
        payload: {
          statusCode: 'error',
          statusText: 'no response'
        }
      });
    });
  });

  // Test case for when postFulFilmentData fails
  it('handles postFulFilmentData failure', async () => {
    (postFulFilmentData as jest.Mock).mockRejectedValue(new Error('API error'));
    
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(store.getActions()).toContainEqual({
        type: 'error/getError',
        payload: {
          statusCode: 'error',
          statusText: 'no response'
        }
      });
    });
  });

  // Test case for when TMXUserSession returns non-pass status
  it('handles non-pass status from TMXUserSession', async () => {
    (postTMXUserSession as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { review_status: 'fail' } 
    });
    
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(store.getActions()).toContainEqual({
        type: 'error/getError',
        payload: {
          statusCode: 'error',
          statusText: 'no response'
        }
      });
    });
  });

  // Test case for when showSpinner is true
  it('shows spinner when showSpinner is true', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // This depends on how your spinner is implemented
    // You might need to mock the Spinner component or check for specific classes
    expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
  });

  // Test case for different language rendering
  it('renders Chinese text when language is set to CN', () => {
    (require('../../../../../utils/common/change.utils').getUrl.getLanguageInfo as jest.Mock).mockReturnValue(CONSTANTS.LANG_CN);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // Replace with actual Chinese text from your constants
    expect(screen.getByText(/Provide documents|上传文件/)).toBeInTheDocument();
  });

  // Test case for different language rendering
  it('renders Hong Kong text when language is set to HK', () => {
    (require('../../../../../utils/common/change.utils').getUrl.getLanguageInfo as jest.Mock).mockReturnValue(CONSTANTS.LANG_HK);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // Replace with actual Hong Kong text from your constants
    expect(screen.getByText(/Provide documents|提供文件/)).toBeInTheDocument();
  });
});

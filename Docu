import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import DucumentUploadMainSCR from './DocumentUploadMainSCR';
import { CONSTANTS } from '../../../../../utils/common/constants';
import { postTMXUserSession, postFinalAcknowledge, postDocSaveData, postFulFilmentData } from '../../../../preApproval/services/preApprovalPostServices';

// Mock the API calls
jest.mock('../../../../preApproval/services/preApprovalPostServices', () => ({
  postTMXUserSession: jest.fn(),
  postFinalAcknowledge: jest.fn(),
  postDocSaveData: jest.fn(),
  postFulFilmentData: jest.fn(),
}));

const mockStore = configureStore([]);

describe('DocumentUploadMainSCR Component - Enhanced Coverage', () => {
  let store: any;

  const baseState = {
    stages: {
      stages: [{
        stageId: 'ld-1',
        stageInfo: {
          applicant_documents: [{
            document_list: [
              {
                document_options: [{
                  document_types: [
                    { uploaded_documents: null }
                  ]
                }]
              },
              {
                document_options: [{
                  document_types: [
                    { uploaded_documents: { id: 'doc2' } }
                  ]
                }]
              }
            ]
          }],
          application: {
            channel_reference: 'test123'
          },
          products: [{
            product_category: 'CC'
          }]
        }
      }],
      dynamicDocumentsUpload: {
        documentData: {},
        HKIDQRCodeData: null,
        documentCount: 1, // 1 out of 2 documents uploaded
        success: true,
        fileSectionData: null,
        changeIconColorIdentityProof: false
      }
    },
    preApproval: {
      resumeAllowed: 'N',
      currentStage: 'PD-1'
    }
  };

  beforeEach(() => {
    store = mockStore(baseState);
    store.dispatch = jest.fn();
    
    // Reset all mocks
    jest.clearAllMocks();
    
    // Default mock implementations
    (postTMXUserSession as jest.Mock).mockResolvedValue({
      status: 200,
      data: { review_status: 'pass' }
    });
    (postFinalAcknowledge as jest.Mock).mockResolvedValue({
      status: 202
    });
    (postDocSaveData as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        application: {
          response_type: 'info',
          response_action: 'continue'
        },
        applicants: [{}],
        applicant_documents: [{}]
      }
    });
    (postFulFilmentData as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        application: {
          response_type: 'info',
          response_action: 'continue'
        },
        applicants: [{}]
      }
    });
  });

  test('should show spinner during API calls in nextStage', async () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'SHOW_LOADER',
        payload: true
      }));
    });
  });

  test('should handle postTMXUserSession failure', async () => {
    (postTMXUserSession as jest.Mock).mockRejectedValue(new Error('API Error'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'ERROR/GET_ERROR'
      }));
    });
  });

  test('should handle HardStop when review_status is not pass', async () => {
    (postTMXUserSession as jest.Mock).mockResolvedValue({
      status: 200,
      data: { review_status: 'fail' }
    });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'ERROR/GET_ERROR'
      }));
    });
  });

  test('should handle postFinalAcknowledge failure', async () => {
    (postFinalAcknowledge as jest.Mock).mockRejectedValue(new Error('API Error'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'ERROR/GET_ERROR'
      }));
    });
  });

  test('should handle postDocSaveData failure', async () => {
    (postDocSaveData as jest.Mock).mockRejectedValue(new Error('API Error'));

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'ERROR/GET_ERROR'
      }));
    });
  });

  test('should handle HardStop from postDocSaveData response', async () => {
    (postDocSaveData as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        application: {
          response_type: 'hard',
          response_action: 'stop'
        }
      }
    });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.any(Function));
    });
  });

  test('should handle non-CC product flow', async () => {
    const customState = {
      ...baseState,
      stages: {
        ...baseState.stages,
        stages: [{
          ...baseState.stages.stages[0],
          stageInfo: {
            ...baseState.stages.stages[0].stageInfo,
            products: [{
              product_category: 'Loan'
            }]
          }
        }]
      }
    };
    store = mockStore(customState);

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'STAGES/GET_STAGE'
        })
      );
    });
  });

  test('should handle FFD2 enable flow', async () => {
    (postFulFilmentData as jest.Mock).mockResolvedValue({
      status: 200,
      data: {
        application: {
          response_type: 'info',
          response_action: 'continue'
        },
        applicants: [{}]
      }
    });

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    const continueButton = screen.getByRole('button', { name: /continue/i });
    fireEvent.click(continueButton);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'STAGES/GET_STAGE'
        })
      );
    });
  });

  test('should handle fileSectionData not null case', () => {
    const customState = {
      ...baseState,
      stages: {
        ...baseState.stages,
        dynamicDocumentsUpload: {
          ...baseState.stages.dynamicDocumentsUpload,
          fileSectionData: { some: 'data' }
        }
      }
    };
    store = mockStore(customState);

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.queryByText(/provide document/i)).not.toBeInTheDocument();
    expect(screen.queryByText(/upload document/i)).not.toBeInTheDocument();
  });

  test('should handle HKIDVersion or showIncomeProof cases', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    // Verify initial class
    expect(screen.getByTestId('document-container')).toHaveClass('document-view');

    // Mock useState to return values that would change the class
    jest.spyOn(React, 'useState')
      .mockImplementationOnce(() => ['income-proof', jest.fn()]) // showIncomeProof
      .mockImplementationOnce(() => [null, jest.fn()]) // HKIDQRCodeData
      .mockImplementationOnce(() => [false, jest.fn()]) // showUploadFileSuccess
      .mockImplementationOnce(() => ['v2', jest.fn()]) // HKIDVersion
      .mockImplementationOnce(() => [false, jest.fn()]); // showContinueBtn

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.getByTestId('document-container')).not.toHaveClass('document-view');
  });

  test('should handle resumeAllowed="Y" scenario', () => {
    const customState = {
      ...baseState,
      preApproval: {
        ...baseState.preApproval,
        resumeAllowed: 'Y'
      },
      stages: {
        ...baseState.stages,
        stages: [{
          ...baseState.stages.stages[0],
          stageInfo: {
            ...baseState.stages.stages[0].stageInfo,
            applicant_documents: [{
              document_list: [
                {
                  document_options: [{
                    document_types: [
                      { uploaded_documents: { id: 'doc1' } }
                    ]
                  }]
                },
                {
                  document_options: [{
                    document_types: [
                      { uploaded_documents: { id: 'doc2' } }
                    ]
                  }]
                }
              ]
            }]
          }
        }]
      }
    };
    store = mockStore(customState);

    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );

    expect(screen.getByText(/2\/2/i)).toBeInTheDocument();
  });
});

import { configureStore } from '@reduxjs/toolkit';
import fieldError, { fieldErrorAction } from './fieldError'; // Adjust the import path as needed

describe('fieldError slice', () => {
  let store: any;

  beforeEach(() => {
    // Create a fresh store before each test
    store = configureStore({
      reducer: {
        fieldError: fieldError.reducer
      }
    });
  });

  describe('getFieldError reducer', () => {
    it('should add a field error if it does not exist', () => {
      // Dispatch the action
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the error was added
      expect(state.error).toContain('username');
      expect(state.error.length).toBe(1);
    });

    it('should not add duplicate field errors', () => {
      // Add the same error twice
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the error was added only once
      expect(state.error).toContain('username');
      expect(state.error.length).toBe(1);
    });

    it('should add multiple different field errors', () => {
      // Add multiple errors
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'password' }));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that both errors were added
      expect(state.error).toContain('username');
      expect(state.error).toContain('password');
      expect(state.error.length).toBe(2);
    });
  });

  describe('removeToggleFieldError reducer', () => {
    it('should remove an existing field error', () => {
      // Add an error first
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      
      // Then remove it
      store.dispatch(fieldErrorAction.removeToggleFieldError('username'));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the error was removed
      expect(state.error).not.toContain('username');
      expect(state.error.length).toBe(0);
    });

    it('should do nothing if the field error does not exist', () => {
      // Add an error
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      
      // Try to remove a non-existent error
      store.dispatch(fieldErrorAction.removeToggleFieldError('email'));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the state remains unchanged
      expect(state.error).toContain('username');
      expect(state.error.length).toBe(1);
    });
  });

  describe('getMandatoryFields reducer', () => {
    it('should set mandatory fields when none exist', () => {
      // Set mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['name', 'email']));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the mandatory fields were set
      expect(state.mandatoryFields).toEqual(['name', 'email']);
    });

    it('should add new mandatory fields without duplicates', () => {
      // Set initial mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['name', 'email']));
      
      // Add more mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['email', 'phone']));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the mandatory fields were updated correctly
      expect(state.mandatoryFields).toContain('name');
      expect(state.mandatoryFields).toContain('email');
      expect(state.mandatoryFields).toContain('phone');
      expect(state.mandatoryFields.length).toBe(3);
    });

    it('should set mandatory fields to null when payload is falsy', () => {
      // Set initial mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['name', 'email']));
      
      // Set mandatory fields to null
      store.dispatch(fieldErrorAction.getMandatoryFields(null));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the mandatory fields were set to null
      expect(state.mandatoryFields).toBeNull();
    });
  });

  describe('removeMandatoryFields reducer', () => {
    it('should remove specified mandatory fields', () => {
      // Set initial mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['name', 'email', 'phone']));
      
      // Remove some mandatory fields
      store.dispatch(fieldErrorAction.removeMandatoryFields(['email']));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the specified mandatory field was removed
      expect(state.mandatoryFields).toContain('name');
      expect(state.mandatoryFields).toContain('phone');
      expect(state.mandatoryFields).not.toContain('email');
      expect(state.mandatoryFields.length).toBe(2);
    });

    it('should handle removing multiple mandatory fields', () => {
      // Set initial mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['name', 'email', 'phone', 'address']));
      
      // Remove multiple mandatory fields
      store.dispatch(fieldErrorAction.removeMandatoryFields(['email', 'phone']));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the specified mandatory fields were removed
      expect(state.mandatoryFields).toContain('name');
      expect(state.mandatoryFields).toContain('address');
      expect(state.mandatoryFields).not.toContain('email');
      expect(state.mandatoryFields).not.toContain('phone');
      expect(state.mandatoryFields.length).toBe(2);
    });

    it('should do nothing if mandatoryFields is null', () => {
      // Set mandatory fields to null
      store.dispatch(fieldErrorAction.getMandatoryFields(null));
      
      // Try to remove mandatory fields
      store.dispatch(fieldErrorAction.removeMandatoryFields(['email']));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the state remains unchanged
      expect(state.mandatoryFields).toBeNull();
    });

    it('should do nothing if the specified field does not exist', () => {
      // Set initial mandatory fields
      store.dispatch(fieldErrorAction.getMandatoryFields(['name', 'email']));
      
      // Try to remove a non-existent field
      store.dispatch(fieldErrorAction.removeMandatoryFields(['phone']));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that the state remains unchanged
      expect(state.mandatoryFields).toEqual(['name', 'email']);
    });
  });

  describe('removeFieldError reducer', () => {
    it('should clear all field errors when payload is truthy', () => {
      // Add some errors first
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'password' }));
      
      // Clear all errors
      store.dispatch(fieldErrorAction.removeFieldError(true));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that all errors were cleared
      expect(state.error).toEqual([]);
    });

    it('should not clear errors when payload is falsy', () => {
      // Add some errors first
      store.dispatch(fieldErrorAction.getFieldError({ fieldName: 'username' }));
      
      // Try to clear errors with falsy payload
      store.dispatch(fieldErrorAction.removeFieldError(false));
      
      // Get the current state
      const state = store.getState().fieldError;
      
      // Assert that errors were not cleared
      expect(state.error).toContain('username');
    });
  });

  describe('initial state', () => {
    it('should have the correct initial state', () => {
      // Get the initial state without dispatching any actions
      const state = store.getState().fieldError;
      
      // Assert the initial state is correct
      expect(state.error).toEqual([]);
      expect(state.mandatoryFields).toEqual([]);
    });
  });
});

import { configureStore } from "@reduxjs/toolkit";
import lovReducer, { lovAction } from "../path/to/your/lov"; // Update this import path to match your project structure

describe("LOV Slice", () => {
  let store;

  beforeEach(() => {
    store = configureStore({
      reducer: {
        lov: lovReducer,
      },
    });
  });

  // Basic test for initial state
  test("should initialize with empty LOV array", () => {
    const state = store.getState().lov;
    expect(state).toEqual({ lov: [] });
  });

  // Test adding a new entry
  test("should add a new LOV entry when it doesn't exist", () => {
    const newLov = {
      label: "test_label",
      value: ["item1", "item2"]
    };
    
    store.dispatch(lovAction.getLovData(newLov));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(1);
    expect(state.lov[0]).toEqual({
      label: "test_label",
      value: ["item1", "item2"]
    });
  });

  // Test not adding duplicate entries (unless they're special cases)
  test("should not add duplicate LOV entries with the same label", () => {
    const lovEntry = {
      label: "regular_label",
      value: ["value1"]
    };
    
    // Add the entry once
    store.dispatch(lovAction.getLovData(lovEntry));
    
    // Try to add it again with different value
    const updatedEntry = {
      label: "regular_label",
      value: ["updated_value"]
    };
    store.dispatch(lovAction.getLovData(updatedEntry));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(1);
    // Should keep the first entry's value
    expect(state.lov[0].value).toEqual(["value1"]);
  });

  // Test the res_city_3 special case
  test("should replace existing res_city_3 entry", () => {
    // First add the initial entry
    const initialEntry = {
      label: "res_city_3",
      value: ["city1"]
    };
    store.dispatch(lovAction.getLovData(initialEntry));
    
    // Add updated entry with the same label
    const updatedEntry = {
      label: "res_city_3",
      value: ["city2", "city3"]
    };
    store.dispatch(lovAction.getLovData(updatedEntry));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(1);
    // Should have updated to the new value
    expect(state.lov[0].value).toEqual(["city2", "city3"]);
  });

  // Test the res_city_4 special case
  test("should replace existing res_city_4 entry", () => {
    // First add the initial entry
    const initialEntry = {
      label: "res_city_4",
      value: ["oldCity"]
    };
    store.dispatch(lovAction.getLovData(initialEntry));
    
    // Add updated entry with the same label
    const updatedEntry = {
      label: "res_city_4",
      value: ["newCity"]
    };
    store.dispatch(lovAction.getLovData(updatedEntry));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(1);
    // Should have updated to the new value
    expect(state.lov[0].value).toEqual(["newCity"]);
  });

  // Test with multiple different entries
  test("should handle multiple different LOV entries", () => {
    // Add three different entries
    store.dispatch(lovAction.getLovData({
      label: "label1",
      value: ["value1"]
    }));
    
    store.dispatch(lovAction.getLovData({
      label: "label2",
      value: ["value2"]
    }));
    
    store.dispatch(lovAction.getLovData({
      label: "label3",
      value: ["value3"]
    }));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(3);
    // Check values are preserved in order
    expect(state.lov[0].label).toBe("label1");
    expect(state.lov[1].label).toBe("label2");
    expect(state.lov[2].label).toBe("label3");
  });

  // Test updating res_city_3 among other entries
  test("should update only res_city_3 when multiple entries exist", () => {
    // Add two different entries
    store.dispatch(lovAction.getLovData({
      label: "regular_label",
      value: ["regular_value"]
    }));
    
    store.dispatch(lovAction.getLovData({
      label: "res_city_3",
      value: ["original_city"]
    }));
    
    // Update res_city_3
    store.dispatch(lovAction.getLovData({
      label: "res_city_3",
      value: ["updated_city"]
    }));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(2);
    
    // Find entries and verify their values
    const regularEntry = state.lov.find(item => item.label === "regular_label");
    const cityEntry = state.lov.find(item => item.label === "res_city_3");
    
    expect(regularEntry.value).toEqual(["regular_value"]);
    expect(cityEntry.value).toEqual(["updated_city"]);
  });

  // Test the behavior with empty values
  test("should handle entries with empty values", () => {
    const emptyValueEntry = {
      label: "empty_label",
      value: []
    };
    
    store.dispatch(lovAction.getLovData(emptyValueEntry));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(1);
    expect(state.lov[0]).toEqual({
      label: "empty_label",
      value: []
    });
  });

  // Test the behavior with object values instead of arrays
  test("should handle entries with object values", () => {
    const objectValueEntry = {
      label: "object_label",
      value: { key: "value" }
    };
    
    store.dispatch(lovAction.getLovData(objectValueEntry));
    
    const state = store.getState().lov;
    expect(state.lov.length).toBe(1);
    expect(state.lov[0]).toEqual({
      label: "object_label",
      value: { key: "value" }
    });
  });
});

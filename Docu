import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import AddressSearch from './AddressSearch';
import { CONSTANTS } from '../../../utils/common/constants';
import { addressSearchRequest } from '../../../services/common-service';

// Mock the services and utilities
jest.mock('../../../services/common-service', () => ({
  addressSearchRequest: jest.fn(),
}));

jest.mock('../../../utils/common/change.utils', () => ({
  fieldError: jest.fn(),
  getUrl: {
    getLanguageInfo: jest.fn(() => CONSTANTS.LANG_EN),
    getParameterByName: jest.fn(() => null),
  },
}));

// Mock Redux store
const mockStore = configureStore([]);

describe('AddressSearch Component', () => {
  const mockData = {
    logical_field_name: 'res_building_estate_pt',
    rwb_label_name: 'Building/Estate',
    mandatory: 'Yes',
    length: 100,
    editable: false,
  };

  const mockHandleCallback = jest.fn();
  const mockHandleFieldDispatch = jest.fn();

  const renderComponent = (props: any = {}, storeState: any = {}) => {
    const store = mockStore({
      stages: {
        stages: [
          {
            stageId: 'bd-1',
            stageInfo: {
              applicants: [{}],
            },
          },
        ],
        userInput: {
          applicants: [{}],
        },
      },
      fielderror: { error: [] },
      preApproval: { resumeAllowed: 'N' },
      ...storeState,
    });

    return render(
      <Provider store={store}>
        <AddressSearch
          data={mockData}
          handleCallback={mockHandleCallback}
          handleFieldDispatch={mockHandleFieldDispatch}
          {...props}
        />
      </Provider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders with default props', () => {
    renderComponent();
    expect(screen.getByLabelText('Building/Estate')).toBeInTheDocument();
  });

  test('displays label and input field correctly', () => {
    renderComponent();
    expect(screen.getByText('Building/Estate')).toBeInTheDocument();
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  test('shows error when field is mandatory and empty', () => {
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Test' } });
    fireEvent.change(input, { target: { value: '' } });
    expect(screen.getByText(/Building\/Estate is required/)).toBeInTheDocument();
  });

  test('validates input against regex pattern', async () => {
    renderComponent();
    const input = screen.getByRole('textbox');
    
    // Test invalid characters
    fireEvent.change(input, { target: { value: 'Test@123' } });
    expect(screen.getByText(/Special characters are not allowed/)).toBeInTheDocument();
    
    // Test valid input
    fireEvent.change(input, { target: { value: 'Valid Input 123' } });
    await waitFor(() => {
      expect(screen.queryByText(/Special characters are not allowed/)).not.toBeInTheDocument();
    });
  });

  test('triggers address search when input length > 2', async () => {
    const mockResponse = new DOMParser().parseFromString(
      `<AddressLookupResult>
        <SuggestedAddress>
          <PremisesAddress>
            <EngPremisesAddress>
              <EngEstate><EstateName>Test Estate</EstateName></EngEstate>
              <EngStreet><StreetName>Test Street</StreetName></EngStreet>
              <EngDistrict><DcDistrict>Test District</DcDistrict></EngDistrict>
              <Region>HK</Region>
            </EngPremisesAddress>
          </PremisesAddress>
        </SuggestedAddress>
      </AddressLookupResult>`,
      'text/xml'
    );

    (addressSearchRequest as jest.Mock).mockResolvedValue(mockResponse);
    
    renderComponent();
    const input = screen.getByRole('textbox();
    fireEvent.change(input, { target: { value: 'Test' } });
    
    await waitFor(() => {
      expect(addressSearchRequest).toHaveBeenCalledWith('Test');
    });
  });

  test('displays address suggestions in datalist', async () => {
    const mockResponse = new DOMParser().parseFromString(
      `<AddressLookupResult>
        <SuggestedAddress>
          <PremisesAddress>
            <EngPremisesAddress>
              <EngEstate><EstateName>Test Estate 1</EstateName></EngEstate>
            </EngPremisesAddress>
          </PremisesAddress>
        </SuggestedAddress>
        <SuggestedAddress>
          <PremisesAddress>
            <EngPremisesAddress>
              <EngEstate><EstateName>Test Estate 2</EstateName></EngEstate>
            </EngPremisesAddress>
          </PremisesAddress>
        </SuggestedAddress>
      </AddressLookupResult>`,
      'text/xml'
    );

    (addressSearchRequest as jest.Mock).mockResolvedValue(mockResponse);
    
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Test' } });
    
    await waitFor(() => {
      const options = screen.getAllByRole('option');
      expect(options).toHaveLength(2);
      expect(options[0]).toHaveValue('Test Estate 1');
      expect(options[1]).toHaveValue('Test Estate 2');
    });
  });

  test('handles estate selection and dispatches address parts', async () => {
    const mockResponse = new DOMParser().parseFromString(
      `<AddressLookupResult>
        <SuggestedAddress>
          <PremisesAddress>
            <EngPremisesAddress>
              <EngEstate><EstateName>Test Estate</EstateName></EngEstate>
              <EngStreet><StreetName>Test Street</StreetName></EngStreet>
              <EngDistrict><DcDistrict>Test District</DcDistrict></EngDistrict>
              <Region>HK</Region>
            </EngPremisesAddress>
          </PremisesAddress>
        </SuggestedAddress>
      </AddressLookupResult>`,
      'text/xml'
    );

    (addressSearchRequest as jest.Mock).mockResolvedValue(mockResponse);
    
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Test Estate' } });
    
    await waitFor(() => {
      expect(mockHandleFieldDispatch).toHaveBeenCalledWith('res_name_of_Street', 'Test Street');
      expect(mockHandleFieldDispatch).toHaveBeenCalledWith('res_district', 'Test District');
      expect(mockHandleFieldDispatch).toHaveBeenCalledWith('res_city', 'A00');
    });
  });

  test('displays Chinese error messages when language is CN', () => {
    require('../../../utils/common/change.utils').getUrl.getLanguageInfo.mockReturnValue(CONSTANTS.LANG_CN);
    
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Invalid@Input' } });
    
    expect(screen.getByText(/請輸入有效的建築物\/屋苑名稱/)).toBeInTheDocument();
  });

  test('loads default value from resume data when resumeAllowed is Y', () => {
    const storeState = {
      preApproval: { resumeAllowed: 'Y' },
      stages: {
        stages: [
          {
            stageId: 'bd-1',
            stageInfo: {
              applicants: [{ res_building_estate_pt_a_1: 'Resume Value' }],
            },
          },
        ],
        userInput: {
          applicants: [{}],
        },
      },
    };
    
    renderComponent({}, storeState);
    expect(screen.getByRole('textbox')).toHaveValue('Resume Value');
  });

  test('disables input when editable is true', () => {
    renderComponent({ data: { ...mockData, editable: true } });
    expect(screen.getByRole('textbox')).toBeDisabled();
  });

  test('shows tick mark when value is valid', () => {
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Valid Input' } });
    expect(document.querySelector('.tick-class')).toBeInTheDocument();
  });

  test('handles API error gracefully', async () => {
    (addressSearchRequest as jest.Mock).mockRejectedValue(new Error('API Error'));
    
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Test' } });
    
    await waitFor(() => {
      // Verify component doesn't crash and continues normal operation
      expect(input).toHaveValue('Test');
    });
  });

  test('handles empty API response', async () => {
    const mockResponse = new DOMParser().parseFromString(
      `<AddressLookupResult></AddressLookupResult>`,
      'text/xml'
    );

    (addressSearchRequest as jest.Mock).mockResolvedValue(mockResponse);
    
    renderComponent();
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'Test' } });
    
    await waitFor(() => {
      // Verify no options are shown when response is empty
      expect(screen.queryByRole('option')).not.toBeInTheDocument();
    });
  });
});

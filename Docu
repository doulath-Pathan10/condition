import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import DucumentUploadMainSCR from './DocumentUploadMainSCR';
import { CONSTANTS } from '../../../../../utils/common/constants';
import { postDocSaveData, postFinalAcknowledge, postFulFilmentData, postTMXUserSession } from '../../../../preApproval/services/preApprovalPostServices';
import { dispatchLoader } from '../../../../../services/common-service';

// Mock the services and utilities
jest.mock('../../../../preApproval/services/preApprovalPostServices');
jest.mock('../../../../../services/common-service');
jest.mock('../../../../../utils/common/change.utils');

const mockStore = configureStore([]);

describe('DocumentUploadMainSCR Component', () => {
  let store: any;
  const initialState = {
    stages: {
      stages: [{
        stageId: 'ld-1',
        stageInfo: {
          applicant_documents: [{
            document_list: [
              {
                document_options: [{
                  document_types: [
                    { uploaded_documents: null },
                    { uploaded_documents: { id: 1 } }
                  ]
                }]
              }
            ]
          }],
          application: {
            channel_reference: 'test-ref'
          },
          products: [{
            product_category: 'CC'
          }]
        }
      }],
      dynamicDocumentsUpload: {
        documentData: {},
        HKIDQRCodeData: null,
        documentCount: 1,
        success: true,
        fileSectionData: null
      }
    },
    preApproval: {
      resumeAllowed: 'N',
      currentStage: 'PD-1'
    }
  };

  beforeEach(() => {
    store = mockStore(initialState);
    (postTMXUserSession as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { review_status: 'pass' } 
    });
    (postFinalAcknowledge as jest.Mock).mockResolvedValue({ status: 202 });
    (postDocSaveData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {},
        applicant_documents: []
      } 
    });
    (postFulFilmentData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {}
      } 
    });
    (dispatchLoader as jest.Mock).mockReturnValue({ type: 'LOADER_ACTION' });
    (require('../../../../../utils/common/change.utils').getUrl.getParameterByName as jest.Mock).mockReturnValue(null);
    (require('../../../../../utils/common/change.utils').getUrl.getLanguageInfo as jest.Mock).mockReturnValue(CONSTANTS.LANG_EN);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('renders without crashing', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText('Provide documents')).toBeInTheDocument();
  });

  it('displays document count correctly', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText('1/2')).toBeInTheDocument();
  });

  it('shows continue button when success is true', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    expect(screen.getByText('Continue')).toBeInTheDocument();
  });

  it('disables continue button when not all documents are uploaded', () => {
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    const button = screen.getByText('Continue');
    expect(button).toBeDisabled();
  });

  it('enables continue button when all documents are uploaded', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    const button = screen.getByText('Continue');
    expect(button).not.toBeDisabled();
  });

  it('calls nextStage when continue button is clicked', async () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postTMXUserSession).toHaveBeenCalled();
      expect(postFinalAcknowledge).toHaveBeenCalled();
      expect(postDocSaveData).toHaveBeenCalled();
    });
  });

  it('handles resumeAllowed case correctly', () => {
    const customState = {
      ...initialState,
      preApproval: {
        ...initialState.preApproval,
        resumeAllowed: 'Y'
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // Verify document count is calculated from uploaded_documents
    expect(screen.getByText('1/2')).toBeInTheDocument();
  });

  it('handles resumePage case correctly', () => {
    (require('../../../../../utils/common/change.utils').getUrl.getParameterByName as jest.Mock).mockReturnValue('resume');
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // Verify document count is calculated from uploaded_documents
    expect(screen.getByText('1/2')).toBeInTheDocument();
  });

  it('shows spinner during loading', () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        stages: [{
          ...initialState.stages.stages[0],
          stageId: 'ffd-1'
        }]
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  it('handles postFulFilment success case', async () => {
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(postFulFilmentData).toHaveBeenCalled();
    });
  });

  it('handles error case in postTMXUserSession', async () => {
    (postTMXUserSession as jest.Mock).mockRejectedValue(new Error('API error'));
    
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(store.getActions()).toContainEqual({
        type: 'error/getError',
        payload: {
          statusCode: 'error',
          statusText: 'no response'
        }
      });
    });
  });

  it('handles non-CC product category case', async () => {
    const customState = {
      ...initialState,
      stages: {
        stages: [{
          stageId: 'ld-1',
          stageInfo: {
            ...initialState.stages.stages[0].stageInfo,
            products: [{
              product_category: 'loan'
            }]
          }
        }],
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    (postDocSaveData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'info', 
          response_action: 'continue' 
        },
        applicants: {},
        applicant_documents: []
      } 
    });
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(store.getActions()).toContainEqual({
        type: 'preApproval/setCurrentStage',
        payload: 'PD-3'
      });
    });
  });

  it('handles HardStop case when response action is not continue', async () => {
    (postDocSaveData as jest.Mock).mockResolvedValue({ 
      status: 200, 
      data: { 
        application: { 
          response_type: 'hard', 
          response_action: 'stop' 
        }
      } 
    });
    
    const customState = {
      ...initialState,
      stages: {
        ...initialState.stages,
        dynamicDocumentsUpload: {
          ...initialState.stages.dynamicDocumentsUpload,
          documentCount: 2
        }
      }
    };
    store = mockStore(customState);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    const button = screen.getByText('Continue');
    fireEvent.click(button);
    
    await waitFor(() => {
      // Verify HardStop was called (would need to mock HardStop to verify)
      expect(store.getActions()).not.toContainEqual({
        type: 'preApproval/setCurrentStage',
        payload: 'PD-3'
      });
    });
  });

  it('renders different language content', () => {
    (require('../../../../../utils/common/change.utils').getUrl.getLanguageInfo as jest.Mock).mockReturnValue(CONSTANTS.LANG_CN);
    
    render(
      <Provider store={store}>
        <DucumentUploadMainSCR />
      </Provider>
    );
    
    // Verify Chinese text is rendered (would need actual Chinese constants to match)
    expect(screen.getByText(/Provide documents|上传文件/)).toBeInTheDocument();
  });
});

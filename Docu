import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import { MemoryRouter } from 'react-router-dom';
import PILDashboard from './PILDashboard';

// Previous mocks setup...

describe('PILDashboard Error Handling', () => {
  let store;
  const mockDispatch = jest.fn();

  beforeEach(() => {
    store = configureStore({
      reducer: {
        preApproval: () => ({
          formConfigmetaData: { fieldmetadata: { data: { stages: [] } },
          currentStage: 'PD-1',
          previousStage: 'PD-0',
        }),
        auth: () => ({ sessionUid: null }),
        stages: () => ({ otpOpen: false, stages: [] }),
        urlParam: () => ({ validUrl: true, isResume: false }),
        loader: () => ({ isFetching: false }),
      },
    });

    useDispatch.mockReturnValue(mockDispatch);
    useSelector.mockImplementation((callback) => callback(store.getState()));
    useLocation.mockReturnValue({ search: '', pathname: '/' });
    window.location.search = '?product=123&source=01&lang=en';
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('handles session creation failure', async () => {
    const errorResponse = {
      response: {
        status: 500,
        statusText: 'Internal Server Error',
      },
    };

    require('../services/preApprovalServices').getSessionByPreLogin.mockRejectedValue(errorResponse);

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(
        errorAction.getError({
          statusCode: 500,
          statusText: 'Internal Server Error',
        })
      );
    });
  });

  it('handles product metadata fetch failure', async () => {
    const errorResponse = {
      response: {
        status: 404,
        statusText: 'Not Found',
      },
    };

    require('../services/preApprovalServices').getProductMetaDataInfo.mockRejectedValue(errorResponse);
    require('../services/preApprovalServices').getSessionByPreLogin.mockResolvedValue({
      status: 201,
      headers: { sessionuid: 'test-session' },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(
        errorAction.getError({
          statusCode: 404,
          statusText: 'Not Found',
        })
      );
    });
  });

  it('handles form config fetch failure', async () => {
    const errorResponse = {
      response: {
        status: 400,
        statusText: 'Bad Request',
      },
    };

    require('../services/preApprovalServices').getDataFormConfig.mockRejectedValue(errorResponse);
    require('../services/preApprovalServices').getSessionByPreLogin.mockResolvedValue({
      status: 201,
      headers: { sessionuid: 'test-session' },
    });
    require('../services/preApprovalServices').getProductMetaDataInfo.mockResolvedValue({});

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(
        errorAction.getError({
          statusCode: 400,
          statusText: 'Bad Request',
        })
      );
    });
  });

  it('shows RESUBMIT modal when response_action is RESUBMIT', async () => {
    window.location.search = '?pageId=resume&appRefNo=test123';
    useSelector.mockImplementation((callback) => callback({
      ...store.getState(),
      urlParam: { validUrl: true, isResume: true },
    }));

    const mockResponse = {
      status: 200,
      data: {
        applicants: [],
        application: { 
          application_reference: 'ref123', 
          cos_ref_number: 'cos123', 
          application_status: 'A01',
          response_type: 'HARD',
          response_action: 'RESUBMIT',
          error: {
            application_error: [{ rtobCode: 'A20', error_description: 'Please resubmit your application' }],
          },
        },
        products: [],
        stage: { page_id: 'bd-1' },
      },
    };

    require('../services/preApprovalPostServices').getResumeRequest.mockResolvedValue(mockResponse);

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(screen.getByText('AlertModal: RESUBMIT')).toBeInTheDocument();
      expect(screen.getByText('Go Back')).toBeInTheDocument();
    });
  });

  it('shows ErrorCode modal for CSL-REG-104 error', async () => {
    window.location.search = '?pageId=resume&appRefNo=test123';
    useSelector.mockImplementation((callback) => callback({
      ...store.getState(),
      urlParam: { validUrl: true, isResume: true },
    }));

    const mockResponse = {
      status: 200,
      data: {
        applicants: [],
        application: { 
          application_reference: 'ref123', 
          cos_ref_number: 'cos123', 
          application_status: 'A01',
          error: {
            application_error: [{ rtobCode: 'CSL-REG-104', error_description: 'Registration error' }],
          },
        },
        products: [],
        stage: { page_id: 'bd-1' },
      },
    };

    require('../services/preApprovalPostServices').getResumeRequest.mockResolvedValue(mockResponse);

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(screen.getByText('AlertModal: ErrorCode')).toBeInTheDocument();
    });
  });

  it('handles network errors during resume request', async () => {
    window.location.search = '?pageId=resume&appRefNo=test123';
    useSelector.mockImplementation((callback) => callback({
      ...store.getState(),
      urlParam: { validUrl: true, isResume: true },
    }));

    require('../services/preApprovalPostServices').getResumeRequest.mockRejectedValue(new Error('Network Error'));

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(
        errorAction.getError({
          statusCode: 'error',
          statusText: 'no response',
        })
      );
    });
  });

  it('handles empty response from resume request', async () => {
    window.location.search = '?pageId=resume&appRefNo=test123';
    useSelector.mockImplementation((callback) => callback({
      ...store.getState(),
      urlParam: { validUrl: true, isResume: true },
    }));

    require('../services/preApprovalPostServices').getResumeRequest.mockResolvedValue({});

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(
        errorAction.getError({
          statusCode: 'error',
          statusText: 'no response',
        })
      );
    });
  });

  it('handles application status E01', async () => {
    window.location.search = '?pageId=resume&appRefNo=test123';
    useSelector.mockImplementation((callback) => callback({
      ...store.getState(),
      urlParam: { validUrl: true, isResume: true },
    }));

    const mockResponse = {
      status: 200,
      data: {
        applicants: [],
        application: { 
          application_reference: 'ref123', 
          cos_ref_number: 'cos123', 
          application_status: 'E01',
        },
        products: [],
        stage: { page_id: 'bd-1' },
      },
    };

    require('../services/preApprovalPostServices').getResumeRequest.mockResolvedValue(mockResponse);

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(
        errorAction.getError({
          statusCode: 'error',
          statusText: 'no response',
        })
      );
    });
  });

  it('handles CORRECT RESUBMIT response action', async () => {
    window.location.search = '?pageId=resume&appRefNo=test123';
    useSelector.mockImplementation((callback) => callback({
      ...store.getState(),
      urlParam: { validUrl: true, isResume: true },
    }));

    const mockResponse = {
      status: 200,
      data: {
        applicants: [],
        application: { 
          application_reference: 'ref123', 
          cos_ref_number: 'cos123', 
          application_status: 'A01',
          response_type: 'HARD',
          response_action: 'CORRECT RESUBMIT',
          error: {
            application_error: [{ rtobCode: 'A30', error_description: 'Please correct and resubmit' }],
          },
        },
        products: [],
        stage: { page_id: 'bd-1' },
      },
    };

    require('../services/preApprovalPostServices').getResumeRequest.mockResolvedValue(mockResponse);

    render(
      <Provider store={store}>
        <MemoryRouter>
          <PILDashboard />
        </MemoryRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(screen.getByText('AlertModal: RESUBMIT')).toBeInTheDocument();
    });
  });
});

import { render, screen } from '@testing-library/react';
import LoanDisbursement from './LoanDisbursement';

test('renders LoanDisbursement component', () => {
  render(<LoanDisbursement />);
  const headerContent = screen.getByText('Congratulations!');
  expect(headerContent).toBeInTheDocument();
});
test('initializes state with correct values', () => {
  render(<LoanDisbursement />);
  const loanAmountInput = screen.getByDisplayValue('10000');  // assuming mock data for defaultValue
  expect(loanAmountInput).toBeInTheDocument();
});
test('updates loan amount when changed', () => {
  render(<LoanDisbursement />);
  const loanAmountInput = screen.getByRole('textbox');
  fireEvent.change(loanAmountInput, { target: { value: '20000' } });
  expect(loanAmountInput.value).toBe('20000');
});
test('updates loan tenor when changed', () => {
  render(<LoanDisbursement />);
  const tenorSelect = screen.getByRole('combobox');
  fireEvent.change(tenorSelect, { target: { value: '24' } });
  expect(tenorSelect.value).toBe('24');
});
import { waitFor } from '@testing-library/react';

test('debounced loan amount update', async () => {
  render(<LoanDisbursement />);
  const loanAmountInput = screen.getByRole('textbox');
  fireEvent.change(loanAmountInput, { target: { value: '25000' } });

  await waitFor(() => {
    expect(loanAmountInput.value).toBe('25000');
  });
});
import * as services from '../../services/preApprovalServices';

test('calls API for loan calculation and updates UI', async () => {
  const getOfferCalulatedMock = jest.spyOn(services, 'getOfferCalulated').mockResolvedValue({
    status: 200,
    data: {
      apr: '3.5%',
      monthly_flat_rate: '1.2%',
      repayment_amount: '5000',
    },
  });

  render(<LoanDisbursement />);
  
  const loanAmountInput = screen.getByRole('textbox');
  fireEvent.change(loanAmountInput, { target: { value: '20000' } });

  await waitFor(() => {
    expect(getOfferCalulatedMock).toHaveBeenCalledWith({ requested_tenure: '60', requested_amount: '20000' });
    expect(screen.getByText('APR: 3.5%')).toBeInTheDocument();
    expect(screen.getByText('Monthly Repayment: 5000')).toBeInTheDocument();
  });
});
import * as services from '../../services/preApprovalServices';

test('calls API for loan calculation and updates UI', async () => {
  const getOfferCalulatedMock = jest.spyOn(services, 'getOfferCalulated').mockResolvedValue({
    status: 200,
    data: {
      apr: '3.5%',
      monthly_flat_rate: '1.2%',
      repayment_amount: '5000',
    },
  });

  render(<LoanDisbursement />);
  
  const loanAmountInput = screen.getByRole('textbox');
  fireEvent.change(loanAmountInput, { target: { value: '20000' } });

  await waitFor(() => {
    expect(getOfferCalulatedMock).toHaveBeenCalledWith({ requested_tenure: '60', requested_amount: '20000' });
    expect(screen.getByText('APR: 3.5%')).toBeInTheDocument();
    expect(screen.getByText('Monthly Repayment: 5000')).toBeInTheDocument();
  });
});
test('navigates to next stage on confirm', () => {
  const dispatchMock = jest.fn();
  render(<LoanDisbursement />);
  
  const confirmButton = screen.getByText('Confirm to Proceed');
  fireEvent.click(confirmButton);

  expect(dispatchMock).toHaveBeenCalledWith(expect.objectContaining({
    type: 'stages/updateStageId',
    payload: { id: 'ACD_4' },
  }));
});
test('handles API call errors correctly', async () => {
  const error = new Error('Network Error');
  jest.spyOn(services, 'getOfferCalulated').mockRejectedValueOnce(error);

  render(<LoanDisbursement />);
  
  const loanAmountInput = screen.getByRole('textbox');
  fireEvent.change(loanAmountInput, { target: { value: '30000' } });

  await waitFor(() => {
    expect(screen.getByText('Error: Network Error')).toBeInTheDocument();
  });
});
